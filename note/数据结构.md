# **数据结构**
# 第2章 线性表

## 2.1 线性表的基本概念

### 2.1.2 线性表的抽象数据类型

线性表的抽象数据类型从逻辑上定义线性表这种数据结构的数据对象、数据对象之间的关系，以及相关的基本操作。其中，数据对象说明线性表中的每个数据元素均属于某个类型（如整型、实型或字符型等），这里用一个集合表示：$$D = \{a_i | a_i \in ElemSet, i=1,2,\cdots,n, n \geq 0\}$$数据对象定义完后，我们来定义数据对象中数据元素之间的关系，这里线性关系运用$<a_{i-1}, a_i>$序偶对来表示前驱和后继的关系。数据对象以及数据元素之间的关系定义完后，再给出发生在这些数据对象上的操作。线性表的抽象数据类型定义如下。

```cpp
ADT List
{
    数据对象：$D = \{a_i | a_i \in ElemSet, i=1,2,\cdots,n, n \geq 0\}$
    数据关系：$R1 = \{<a_{i-1}, a_i> | a_{i-1}, a_i \in D, i=2,\cdots,n\}$
    基本操作：
        InitList(&L)          // 初始化线性表
        CreateList(&L)        // 创建线性表
        DestroyList(&L)       // 销毁线性表
        ListLength(L)         // 求表 L 的长度
        Locate(L, e)          // 查找表 L 中值为 e 的元素
        GetElem(L, i, &e)     // 取元素$a_i$，由 e 返回$a_i$
        PriorElem(L, ce, &pre_e) // 求 ce 的前驱，由 pre_e 返回
        InsertElem(&L, i, e)  // 在元素$a_i$之前插入新元素 e
        DeleteElem(&L, i)     // 删除第 i 个元素
        EmptyList(L)          // 判断 L 是否为空表
}
```

这里抽象数据类型定义的操作均是常见的基本操作，是构成复杂操作的基础。我们可把这些基本操作看成搭建模型的基本零件，复杂算法就是由这些基本操作根据不同的组合搭建而成的。

## 2.2 线性表顺序存储结构及实现
### 2.2.1 顺序存储结构的线性表定义

顺序存储结构的线性表定义如下。

```cpp
#define MaxLength 100
typedef struct {
    ElemType elem[MaxLength]; // 下标为 0, 1, ..., MaxLength-1
    int length;               // 当前长度
    int last;                 //$a_n$的位置
} SqList;
```

精简后对线性表顺序存储结构的定义如下。

```cpp
#define MaxLength 100
typedef struct {
    ElemType elem[MaxLength]; // 下标为 0, 1, ..., MaxLength-1
    int length;               // 表长
} SqList;
```

其中，`elem` 是一个大小为 `MaxLength` 的数据元素数组；`length` 为线性表表长；`SqList` 为此结构类型定义的名称。

### 2.2.2 顺序表的基本操作实现

#### 动态分配的顺序存储结构

动态分配，即当数据元素超过所分配存储空间的大小时，在堆空间中再找一片更大的连续空间重新分配，将所有的数据元素放入。顺序存储的动态分配定义如下。

```cpp
#define LIST_INIT_SIZE 100
#define LISTINCREMENT 10
typedef struct {
    ElemType *elem;           // 存储空间基地址
    int length;               // 表长
    int listsize;             // 当前分配的存储容量，以 sizeof(ElemType) 为单位
} SqList;
```

其中，`LIST_INIT_SIZE` 表示第一次为顺序表分配的存储空间大小；`LISTINCREMENT` 表示每次需要扩充存储空间时的增量；`elem` 是一个元素的指针，保存存储空间中第一个数据元素的地址，并且一旦需要扩充线性表的存储空间，可能需要改变 `elem`，使其指向新空间的起始位置。由于存储空间的大小不是固定的，因此这里增加了一个属性 `listsize` 来记录当前实际存储空间的大小。

#### 静态分配插入算法

静态分配插入算法的基本思想为：先判断插入的位置是否合理，接着判断表长是否达到分配空间的最大值，然后从线性表中的最后一个元素到插入位置的所有元素，依次往后移动一个元素的位置，这样给待插入的元素留出一个空位置，最后把新增元素插入这个空位置，表长增加 1，插入成功返回。

```cpp
// 静态分配顺序表插入算法，用引用参数表示被操作的线性表
Status Insert(SqList *L, int i, ElemType e)
{
    int j;
    if (i < 1 || i > L->length + 1) return ERROR; // i 值不合法
    if (L->length >= MaxLength) return OVERFLOW;  // 溢出
    for (j = L->length - 1; j >= i - 1; j--) {
        L->elem[j + 1] = L->elem[j]; // 向后移动元素
    }
    L->elem[i - 1] = e;              // 插入新元素
    L->length++;                     // 长度变量增 1
    return OK;                       // 插入成功
}
```



#### 动态分配插入算法

```cpp
// 动态分配顺序表插入算法
Status Insert(SqList *L, int i, ElemType e)
{
    int j;
    if (i < 1 || i > L->length + 1) // i 的合法取值为 1 ~ length+1
        return ERROR;
    if (L->length >= L->listsize) { // 溢出时扩充
        ElemType *newbase;
        newbase = (ElemType *) realloc(L->elem, (L->listsize + LISTINCREMENT) * sizeof(ElemType));
        if (newbase == NULL) return OVERFLOW; // 扩充失败
        L->elem = newbase;
        L->listsize += LISTINCREMENT;
    }
    for (j = L->length - 1; j >= i - 1; j--) { // 向后移动元素，空出第 i 个元素的分量 elem[i-1]
        L->elem[j + 1] = L->elem[j];
    }
    L->elem[i - 1] = e; // 新元素插入
    L->length++;        // 线性表长度加 1
    return OK;
}
```
#### 删除元素算法
顺序表删除元素算法的基本思想为：首先判断删除元素的下标是否存在，然后用一个 `for` 循环来移动元素，移动元素下标范围为 `i ~ length-1`，最后修改表长为原表长减 1。算法如下所示。

```cpp
// 顺序表删除元素
Status Delete(SqList* L, int i)
{
    if (i < 1 || i > L->length)
        return ERROR;
    int j;
    for (j = i; j <= L->length - 1; j++) {
        L->elem[j - 1] = L->elem[j];
    }
    L->length--;
    return OK;
}
```
## 2.3 线性表链式存储结构定义及实现

#### 链式存储结构概述
链式存储结构是指将线性表中的数据元素存放到计算机存储器内一组非连续存储单元中。在链式结构中，只能通过指针来维护数据元素间的关系。由于这个原因，对线性表中的元素只能进行顺序访问，也就是要访问第$i$个元素，必须先访问前面的$i-1$个元素。

#### 单链表的基本概念
单链表是链式存储结构中最基础、也是最具代表性的一种存储结构形式。单链表是指线性表的每个结点分散地存储在内存空间中，先后依次用一个指针串联起来。单链表可以分为不带表头结点和带表头结点两种情形。

---

#### 1. 不带表头结点的单链表

其中，线性表中的每个元素通过结点进行存储，结点包含两个属性：`data` 称为数据域，它用于保存元素值；`next` 称为指针域/链域，它用于保存直接后继元素结点的指针、维护元素间的线性关系。`head` 为头指针，它用于存放首元素结点的指针。当 `head == NULL` 时，表示为空表，否则表示为非空表。

---

#### 2. 带表头结点的单链表
##### (1) 非空表
单链表中至少存储一个元素为非空表
其中，头指针 `head` 指向表头结点，表头结点的数据域不放元素，指针域指向首元素结点$a_1$。

##### (2) 空表
单链表中还没有存储数据元素为空表


当 `head->next != NULL` 时，表示为空表，否则表示为非空表。

在具体使用中，究竟是使用带表头结点还是使用不带表头结点取决于实际的应用场景。

---

### 2.3.1 单链表存储结构定义

首先定义单链表的结构类型，每个结点有两个部分：一个部分是数据域 `data`；另一个部分是指针域 `next`。具体定义如下：

```cpp
typedef struct node
{
    ElemType data;         // data 为抽象元素类型
    node* next;            // next 为指针类型
} node, *Linklist;
```

指向结点的指针变量 `head`、`p`、`q` 可定义为：

```cpp
node *head, *p, *q;
Linklist head, p, q;
```

单链表是数据结构中非常重要、也是非常基础的一个类型，接下来所讲解的算法均是在这个数据结构定义的基础上进行的。

---

### 2.3.2 单链表的实现

下面阐述基于单链表的实例，第一个要讲解的算法是如何生成单链表。

#### 1. 先进先出单链表
该单链表中一个结点的数据结构按如下方式定义：

```cpp
#define LENG sizeof(node)     // 结点所占的单元数
struct node
{
    int data;                 // data 为整型
    node* next;              // next 为指针类型
};
```

首先定义结点所占空间大小，结点的数据域为整型数，然后定义指针域 `next`。

由于单链表元素结点次序与元素的输入次序相同，因此每次输入一个元素后，均将新结点插入单链表的尾部作为最后一个结点。为了提高算法效率，使用了一个尾指针 `tail` 指向单链表的最后一个结点，这样就能方便新结点的插入。每次新结点链接到 `tail` 指向的结点之后，再修改 `tail` 指向新结点，使用这种插入方式创建单链表的方法俗称尾插法。算法步骤如下：

1. 生成表头结点，`head` 和 `tail` 都指向表头结点。
2. 输入元素的值 `e`，当元素不是结束标记时，重复下列操作，否则转至步骤 (3)：
   - (1) 生成新结点 `p`，`e` 保存到 `p` 结点的数据域。
   - (2) 使用 `tail->next = p`；将 `p` 结点链接到单链表的表尾。
   - (3) 使用 `tail = p`；让 `tail` 指向当前的表尾结点。
3. 使用 `tail->next = NULL`；将最后一个结点的指针域赋值为空。
4. 返回 `head`，完成“先进先出”单链表的创建。

由此算法步骤得到算法代码如下：

```cpp
// 算法：生成“先进先出”单链表（链式队列）
node* create1()
{
    node *head, *tail, *p;          // 变量说明
    int e;
    head = (node*)malloc(LENG);     // 生成表头结点
    tail = head;                    // 尾指针指向表头
    scanf("%d", &e);                // 输入第一个数
    while (e != 0)                  // 不为 0
    {
        p = (node*)malloc(LENG);    // 生成新结点
        p->data = e;                // 装入输入的元素 e
        tail->next = p;             // 新结点链接到表尾
        tail = p;                   // 尾指针指向新结点
        scanf("%d", &e);            // 再输入一个数
    }
    tail->next = NULL;              // 尾结点的 next 置为空指针
    return head;                    // 返回头指针
}
```

#### 2. 先进后出单链表
为实现创建“先进后出”单链表，每当输入一个元素后，生成的结点不是放在表尾而是插入表头，成为新的首元素结点，使用这种插入方式创建单链表的方法俗称首插法。如图 2.15 所示，当前单链表中已有$i$个元素结点，元素输入次序为$a_1, \cdots, a_i$，现输入第$i+1$个元素$a_{i+1}$，具体操作为：
- 第①步生成新结点$p$，并保存新元素$a_{i+1}$；
- 第②步通过$p->next = head->next$使得新结点指针指向原首结点；
- 第③步通过$head->next = p$让表头结点的指针域指向新结点$a_{i+1}$，不再指向$a_i$，将新结点作为首元素，即可完成将新结点插入表头的操作。

根据以上分析所设计的生成“先进后出”单链表的算法代码如下：

```cpp
node* create2()
{
    node *head, *p;
    int e;
    head = (node*)malloc(LENG);     // 生成表头结点
    head->next = NULL;              // 置为空表
    scanf("%d", &e);                // 输入第一个数
    while (e != 0)                  // 不为 0
    {
        p = (node*)malloc(LENG);    // 生成新结点
        p->data = e;                // 输入数送新结点的 data
        p->next = head->next;       // 新结点指针指向原首结点
        head->next = p;             // 表头结点的指针指向新结点
        scanf("%d", &e);            // 再输入一个数
    }
    return head;                    // 返回头指针
}
```

#### 3. 插入元素
通过以上两个算法的分析，发现不管是生成“先进先出”单链表还是生成“先进后出”单链表，都是不断插入元素的过程，只不过插入元素的位置有所不同。下面说明一般情况下插入元素的操作。

##### (1) 在已知 `p` 指针指向的结点后插入一个元素$x$
首先用一个指针 `f` 指向新结点，该结点的数据域为$x$，然后此新结点 `next` 域赋值为 `p` 指针指向结点的 `next` 域，最后 `p` 指针指向结点的 `next` 域赋值为 `f`，如图 2.16 所示。其具体操作可表示如下：

1.$f = (node *)malloc(LENG)$； // 生成
2.$f->data = x$； // 装入元素$x$
3.$f->next = p->next$； // 新结点指向$p$的后继
4.$p->next = f$； // 新结点成为$p$的后继

##### (2) 在已知 `p` 指针指向的结点前插入一个元素$x$
因为单链表每个结点只有一个指针指向其后继结点，如果在结点前插入一个新结点，就需要得到 `p` 指向结点的前驱结点指针，假设该指针为 `q`。这样问题就转换成在指针 `q` 指向的结点之后插入一个结点，即将该问题 (2) 转换成问题 (1) 求解。这类前后指针的方式在单链表的操作中经常出现，一个指针 `p` 在单链表上移动访问结点，另一个指针 `q` 指向刚访问过的结点，一前一后 2 个指针，使得在单链表中完成结点的插入或删除操作非常方便。

其具体操作可表示如下：

1.$f = (node *)malloc(LENG)$； // 生成
2.$f->data = x$； // 装入元素$x$
3.$f->next = p$； // 新结点成为$p$的前驱
4.$q->next = f$； // 新结点成为$q$的前驱结点的后继

---

### 2.3.3 循环单链表

上文提及的单链表中最后一个结点，其 `next` 域为空。从一已知结点出发，只能访问到该结点及其后续结点，无法找到该结点之前的其他结点。

有的时候，为了应用方便，我们可以将链表中最后一个结点的 `next` 域指向链表的第一个结点而形成一个环，这种单链表称为循环单链表。在循环单链表中，从任一结点出发都可访问到表中所有结点，这一优点使某些运算在循环链表上易于实现。

### 2.3.4 双向链表

单链表和循环单链表每个结点中只有一个指针指向其后继。对于循环单链表，一个结点需要访问其前驱结点时要顺着 `next` 域扫描整个链表一遍，此时效率显然不高。这里为了方便访问结点的前驱结点而引入双向链表。其中，每个结点除了数据域之外，还有两个指针域（一个指向其直接前驱结点，另一个指向其直接后继结点）。

#### 数据结构的定义
```cpp
typedef struct Dnode
{
    ElemType data;         // data 为抽象元素类型
    Dnode *prior, *next;   // prior、next 为指针类型
} Dnode, *DList;           // DList 为指针类型
```

在实际应用中，一般会在双向链表中加上循环，形成双向循环链表。双向循环链表的一般形式如图 2.21 所示，我们可以根据 `L->next == L` 或 `L->prior == L` 是否成立来判断是否为空表。

在双向循环链表中，对于非空表，如果 `p` 指向某个结点$a_i$，$1 \leq i \leq n$，则有 `p->next` 指向$a_{i+1}$，当$i = n$时，`p->next->prior` 又回头指向$a_i$，所以有关系 `p == p->next->prior`；同理可以得到 `p == p->prior->next`。

从双向链表中删除结点时，需要注意两个指针的变化。例如，已知双向链表中包含结点$A$、$B$、$C$，指针 `p` 指向结点$B$，删除$B$，那么所做的操作如下：

1. `p->prior->next = p->next;` // 结点$A$的 `next` 指向结点$C$
2. `p->next->prior = p->prior;` // 结点$C$的 `prior` 指向结点$A$
3. `free(p);` // 释放结点$B$占有的空间

向双向链表中插入结点时，也需要注意两个指针的变化。例如，已知双向链表中包含两个相邻结点$A$和$C$，指针 `p` 指向结点$C$，现在插入一个新的结点到$A$和$C$之间，由 `f` 指向该待插入的结点$B$，那么所做的操作如下：

1. `f->prior = p->prior;` // 结点$B$的 `prior` 指向结点$A$
2. `f->next = p;` // 结点$B$的 `next` 指向结点$C$
3. `p->prior->next = f;` // 结点$A$的 `next` 指向结点$B$
4. `p->prior = f;` // 结点$C$的 `prior` 指向结点$B$

---

## 2.5 应用实例
### 2.5.2 单链表插入、删除算法

单链表插入算法是在单链表的指定位置插入新元素，其中输入参数主要包括头指针 `L`、位置 `i`、数据元素 `e`，而输出为成功返回 `OK`，否则 `ERROR`。首先分析这个算法，在指定位置$i$上插入一个新的元素，使得插入的元素成为链表中的第$i$个元素，那么需要运用指针 `p` 从头扫描单链表，并对所访问的结点进行计数。想一想，计数是在第$i$个位置上结束吗？如果在此结束，指针 `p` 指向第$i$个位置，新元素就要插入指针 `p` 指向的结点之前；之前分析过，如果插入某个结点之前，就需要另一个辅助指针 `q` 来指向指针 `p` 的前驱结点。

实际上，我们是可以简化此过程的，即计数到$i-1$的时候就停止，指针 `p` 指向这个结点，然后新元素插入指针 `p` 所指向结点的后面就达到目的了。扫描的过程即是执行 `p = L`，当指针 `p` 指向的结点不为空时，则需执行 `p = p->next` 指令$i-1$次，从而定位到第$i-1$个结点。当$i < 1$或指针 `p` 所指向的结点为空时，插入点位置出错。

根据以上的分析过程，可以得知在指定位置插入一个新结点的算法如下：

```cpp
Status insert(Linklist L, int i, ElemType e)
{
    node* p = L;
    int j = 1;
    while (p && j < i)
    {
        p = p->next;
        j++;
    }
    if (i < 1 || p == NULL)
        return ERROR;
    node* f = (node *) malloc(LENG);
    f->data = e;
    f->next = p->next;
    p->next = f;
    return OK;
}
```

上文中的几个单链表应用算法均是与在单链表中插入元素的操作相关，下面举例说明在单链表中如何删除元素。在单链表中删除某个结点，一定先找到将要被删除的结点，还要找到其前驱结点。例如，单链表中有 3 个结点，分别是$A$、$B$、$C$，`q` 指针指向数据域为$A$的结点，`p` 指针指向数据域为$B$的结点。如果删除数据域为$B$的结点，首先执行 `q->next = p->next;`，即$A$的 `next` 域指向的地址（$B$的 `next` 域），然后执行 `free(p)`，释放 `p` 所指向的结点空间。

第一个删除算法是在带表头结点的单链表中删除元素值为$e$的结点，那么首先来分析此算法的思想。第一步扫描此单链表以找到元素值为$e$的结点，由于删除此结点需要运用到此结点的前驱结点，那么在扫描过程中需要用到一对指针 `q` 和 `p` 来记录找到的结点和它的前驱结点，一般用如下语句表示：

```cpp
q = head; p = head->next;          // 通过 q、p 扫描
while (p && p->data != e)          // 查找元素为 e 的结点
{
    q = next = p->next;            // 删除该结点
    free(p);                       // 释放结点所占的空间
    return YES;
}
```

第二个算法是在单链表中删除指定位置的元素。在这个 `Delete` 算法中，删除第$i$个元素时，该结点的前驱结点同样重要，因此定位结点也是定位在$i-1$这个位置上，即执行 `p = L;`，`L` 是头指针，当 `p->next` 不为空时执行 `p = p->next; i - 1` 次，从而定位到第$i-1$个结点。接着，判断$i$值，当$i < 1$或 `p->next` 为空时删除点位置出错，否则 `p` 指向后继结点的后继，从而将第$i$个元素结点从单链表中删除。

```cpp
Status Delete(Linklist L, int i)
{
    node* p = L;
    int j = 1;
    while (p->next && j < i)
    {
        p = p->next;
        j++;
    }
    if (i < 1 || p->next == NULL)
        return ERROR;
    node* q = p->next;
    p->next = q->next;
    free(q);
    return OK;
}
```

---

### 2.5.3 单链表合并算法

现用一个例子来说明两个有序单链表的合并算法。

**例 2-9：** 将两个带表头结点的有序单链表$La$和$Lb$合并为有序单链表$Lc$，该算法利用原单链表的结点。单链表合并示意图如图 2.24 所示。

首先是表头结点的征用，即使用$La$的表头结点，释放$Lb$的表头结点，可表示为：

```cpp
struct node *pa, *pb, *pc;
pa = La->next;                     // pa 指向表 La 的首结点
pb = Lb->next;                     // pb 指向表 Lb 的首结点
pc = La;                           // 使用表 La 的表头结点，pc 为尾指针
free(Lb);                          // 释放表 Lb 的表头结点
```

接下来，就是比较 `pa` 和 `pb` 指向结点的数据域值大小。`pa`、`pb`、`pc` 指针根据不同的情况发生变化，直到 `pa` 或 `pb` 为空为止。

```cpp
while (pa && pb)
{
    if (pa->data <= pb->data)
    {
        pc->next = pa;
        pc = pa;
        pa = pa->next;
    }
    else
    {
        pc->next = pb;
        pc = pb;
        pb = pb->next;
    }
}
```

若 `pa` 或 `pb` 不为空，则将剩余的结点插入表$Lc$的尾部。假定$La$和$Lb$两个单链表的表长分别是$m$和$n$，由于合并过程中每个单链表的结点最多被访问一次，因此算法的时间复杂度为$O(m + n)$。

---

### 2.5.4 单链表的逆置

**例 2-10：** 假定以单链表作为线性表$L = (a_1, a_2, \cdots, a_n)$的存储结构，现要求设计算法，将线性表逆置为$L = (a_n, a_{n-1}, \cdots, a_1)$。这个问题就涉及将一个单链表中结点翻转的操作，下面给出该问题求解的 4 种算法，并进行效率分析。

#### 1. 递归算法一

采用递归的思想完成逆置操作。当为空单链表时，作为递归出口，直接返回；对非空单链表，首先将最后一个结点从单链表中移出，将剩下长度减一的单链表翻转过来，再将刚移出的结点作为首结点插入这个单链表中。该递归求解算法描述如下：

```cpp
void reverse1(LinkList L)
{
    LinkList p, q;
    if (L->next == NULL) return;     // 空表时返回递归出口
    p = L; q = L->next;
    while (q->next)
    {
        p = q;
        q = q->next;
    }
    p->next = NULL;                  // 被移出的最后一个结点被 q 指向
    reverse1(L);                     // 递归调用，将剩余的链表结点翻转
    q->next = L->next;               // 被移出的结点再插入作为首结点
    L->next = q;
}
```

该算法每次为了移出最后一个结点，需要对单链表遍历一次，共需要做$n$次移出结点操作，平均每次访问结点的个数为$n/2$，所以算法的时间复杂度$T(n) = O(n^2)$；递归深度为$n$，每一次递归调用时，都会在运行时逻辑空间的栈空间中分配单元，所以空间复杂度$S(n) = O(n)$。

#### 2. 递归算法二

同样是采用递归算法，这里换一种移出结点的方法。当单链表结点个数不大于 1 时，作为递归出口没什么区别，但仔细分析一下会发现，移出第一个结点不需要遍历单链表。同时将移出的结点作为尾结点插入翻转之后的长度减一单链表中也不需要遍历单链表，因为递归后移出的结点指针所指向的结点正好是尾结点。递归求解算法描述如下：

```cpp
void reverse2(LinkList L)
{
    LinkList p = L->next;            // 获得首元素结点
    // 空单链表或只剩一个结点时返回递归出口
    if (L->next == NULL || p->next == NULL)
        return;
    L->next = p->next;
    reverse2(L);
    p->next->next = p;
    p->next = NULL;
}
```

该算法每次为了移出和插入一个结点，都不需要对单链表遍历，共需要做$n$次移出插入结点操作，所以算法的时间复杂度$T(n) = O(n)$；递归深度为$n$，所以空间复杂度$S(n) = O(n)$。

#### 3. 折半与递归算法

同时利用折半和递归的思想将一个长度大于 1 的单链表分成两个等长的子单链表，并分别进行翻转，再合并在一起；单链表长度小于或等于 1 作为递归出口处理。为了方便将单链表一分为二，使用了 `p` 和 `q` 这两个一慢一快的指针，快指针 `q` 每向后移动两次，`p` 才移动一次，这样当 `q` 为空时，`p` 正好指向向前一半的最后一个结点，再增加一个 `L1` 指向的头结点作为后一半结点单链表的头结点，完成单链表的一趟拆分。折半与递归求解算法描述如下：

```cpp
Linklist reverse3(Linklist L)
{
    node* p, *q;
    if (!L->next || !L->next->next)
        return L;                    // 递归出口
    node* L1 = (node*)malloc(LENG);
    p = q = L;
    while (q)
    {
        q = q->next;
        if (q) { q = q->next; }
        p = p->next;
    }
    L1->next = q;
    p->next = NULL;
    L1 = reverse3(L1);
    q->next = L->next;
    free(L);
    L = L1;
    return L;
}
```

该算法大约进行$\log n$趟拆分，能将各子单链表结点的个数减少到 1。每趟拆分时，要遍历全部$n$个结点，所以算法的时间复杂度$T(n) = O(n \log n)$；递归深度为$\log n$，则空间复杂度$S(n) = O(\log n)$。

#### 4. 优化算法

上述 3 种算法中，第二种算法的时间复杂度最高，为$O(n)$。由于逆置过程中必须访问所有结点，因此我们可以认为时间复杂度为$O(n)$已经是最优了，但其空间复杂度为$O(n)$，这样说明该算法还有优化的空间。优化算法思想是：用一个指针 `p` 指向首结点，再将头指针的指针域赋值为空，变成一个空单链表，接着通过 `p` 依次取原单链表中的结点，用首插法将每个结点再插入回单链表中作为首结点，从而完成单链表的逆置。优化算法描述如下：

```cpp
void reverse4(LinkList L)
{
    LinkList p, q;
    p = L->next;
    L->next = NULL;
    while (p)
    {
        q = p->next;
        p->next = L->next;
        L->next = p;
        p = q;
    }
}
```

该优化算法在逆置过程中，每个结点都被处理 1 次，所以时间复杂度$T(n) = O(n)$；空间复杂度$S(n) = O(1)$。由于使用的空间对于问题规模来说是常量，因此优化算法为单链表的就地逆置，也可称为原地工作。
# 第3章 栈与队列

## 3.1 栈

### 3.1.1 栈的基本概念

栈是限定在表尾做插入、删除操作的线性表。向栈中插入元素叫作进栈，从栈中删除元素叫作出栈。栈的表头叫作栈底，栈的表尾叫作栈顶。


栈的相关概念包括以下几个：

- **进栈**：向栈中插入一个元素。其也称为入栈、推入、压入、`push`。
- **出栈**：从栈删除一个元素。其也称为退栈、上托、弹出、`pop`。
- **栈顶**：允许插入、删除元素的一端（表尾）。
- **栈顶元素**：处在栈顶位置的元素（表尾元素）。
- **栈底**：表中不允许插入、删除元素的一端（表头）。
- **空栈**：不含元素的栈。

栈中元素的进出原则：“后进先出”（Last In First Out, LIFO）。

栈的别名：“后进先出”表、LIFO 表、反转存储器、堆栈。

### 3.1.2 栈的抽象数据类型

栈的抽象数据类型如下：

```plaintext
ADT Stack
{
    数据对象：D = {a_i | a_i ∈ ElemSet, i = 1, 2, ..., n, n ≥ 0}
    数据关系：R1 = {<a_{i-1}, a_i> | a_{i-1}, a_i ∈ D, i = 2, ..., n}，其中 a_1 端为栈底，a_n 端为栈顶
    基本操作：
        InitStack(&S)          // 初始化栈 S
        DestroyStack(&S)       // 销毁栈 S
        ClearStack(&S)         // 清空栈 S
        StackLength(S)         // 求栈 S 的长度
        Push(&S, e)            // 在栈 S 的栈顶插入元素 e
        Pop(&S, &e)            // 删除栈 S 的栈顶元素，并赋予变量 e
        GetTop(S, &e)          // 将栈 S 的栈顶元素复制到变量 e
        StackEmpty(S)          // 判断栈 S 是否为空栈
}
End ADT
```

### 3.1.4 栈的顺序存储结构

#### （1）静态分配

```cpp
typedef struct {
    ElemType elem[maxlength];  // 栈元素空间
    int top;                    // 栈顶标识
} SqStack;
SqStack s;
```

#### （2）动态分配

对比线性表静态（动态）分配方式与栈的静态（动态）分配方式可知，在栈的分配方式中，使用了栈顶标识 `top` 替代线性表分配方式中的表长。其原因为：通过基于 `top` 的简单计算，可以得出栈中元素的个数（即得出表长）。

根据上述分析，约定 `top` 指向栈顶元素下一位置，给出如下动态分配顺序栈的基本操作算法。

##### 例 3-1：设计动态分配顺序栈的初始化算法——`InitStack` 函数

首先，调用 `malloc` 函数为顺序栈分配存储空间，然后为栈顶标识 `top` 和当前空间大小 `stacksize` 赋值。

```cpp
#define STACK_INIT_SIZE 100
#define STACKINCREMENT 10

typedef struct {
    ElemType *base;             // 指向栈元素空间
    int top;                    // 栈顶标识
    int stacksize;             // 栈元素空间大小，相当于 maxlength
} SqStack;

void InitStack(SqStack &S) {
    S.base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));
    S.top = 0;                  // 初始化为空栈
    S.stacksize = STACK_INIT_SIZE;
}
```

##### 例 3-2：设计进栈算法——`Push` 函数

首先，判断栈是否已满，如果栈已满，就运用 `realloc` 函数重新开辟更大的栈空间。如果 `realloc` 函数返回值为空，提示“溢出”，则更新栈的地址以及栈的当前空间大小。最终，新元素入栈，栈顶标识 `top` 加 1。

```cpp
Status Push(SqStack &S, ElemType e) {
    if (S.top >= S.stacksize) {
        // 发生溢出，扩充
        ElemType *newbase = (ElemType *)realloc(S.base,
                                                (S.stacksize + STACKINCREMENT) * sizeof(ElemType));
        if (!newbase) {
            printf("溢出");
            return ERROR;
        }
        S.base = newbase;
        S.stacksize += STACKINCREMENT;  // 栈空间扩大
    }
    S.base[S.top] = e;                  // 装入元素 x
    S.top++;                            // 修改顶指针
    return OK;
}
```

##### 例 3-3：设计出栈算法——`Pop` 函数

首先，根据栈顶标识 `top` 判断当前栈是否是一个空栈，如果当前栈是一个空栈，提示“下溢”，否则，更新栈顶标识，取出栈顶元素。

```cpp
Status Pop(SqStack &S, ElemType &e) {
    if (S.top == 0) {
        printf("下溢");
        return ERROR;
    } else {
        S.top--;                      // 修改栈顶指针
        e = S.base[S.top];            // 取出栈顶元素
        return OK;                    // 成功退栈，返回 OK
    }
}
```

上述的 3 个基本算法 `InitStack`、`Push` 和 `Pop` 都可以在主函数中进行调用。假如要对一个栈 `S` 进行操作，首先对其进行类型定义，然后调用 `InitStack` 初始化栈，再进行进栈 `Push` 与退栈 `Pop` 操作，具体代码如下。

```cpp
int main() {
    SqStack S;
    ElemType e;
    InitStack(S);
    Push(S, 10);
    if (Push(S, 20) == ERROR)
        printf("进栈失败！");
    if (Pop(S, e) == OK)
        printf("退栈成功！e=%d", e);
    else
        printf("退栈失败！");
    return 0;
}
```
### 3.1.5 栈的链式存储结构

对于栈的链式存储结构，通常只考虑采用单链表作为栈的存储结构。首先对结点进行如下定义。

```cpp
struct node {
    ElemType data;          // data 为抽象元素类型
    struct node *next;      // next 为指针类型
} *top = NULL;             // 初始化，置 top 为空栈
```

#### 例 3-4：设计链式栈的进栈算法

链式栈的进栈即是压入元素 `e` 到以 `top` 为栈顶指针的链式栈，相当于将新元素 `e` 插入栈顶元素之前。该操作遵循单链表中插入元素的操作方法：首先为新元素分配存储空间，用一个指针 `p` 指向它 “`p = (struct node *)malloc(length);`”，然后对新元素结点的数据域进行赋值 “`p->data = e;`”，再对新元素结点的指针域进行赋值，指向首结点 “`p->next = top;`”，最后修改 `top` 指针指向新元素结点 “`top = p;`”，使其成为新的首结点。

```cpp
struct node *Push_link(struct node *top, ElemType e) {
    struct node *p;
    int length = sizeof(struct node);     // 确定新结点空间的大小
    p = (struct node *)malloc(length);    // 生成新结点
    p->data = e;                          // 装入元素 e
    p->next = top;                        // 插入新结点
    top = p;                              // top 指向新结点
    return top;                           // 返回指针 top
}
```

#### 例 3-5：设计链式栈的出栈算法

链式栈的退栈，即将首元素删除。首先，运用一个新指针指向栈顶结点 “`p = top;`”，然后修改 `top` 指针，使其指向第二个结点，从而删除栈顶结点 “`top = top->next;`”，最后释放原栈顶结点占据的存储空间 “`free(p);`”。

```cpp
struct node *Pop_link(struct node *top, ElemType *e) {
    struct node *p;
    if (top == NULL) return NULL;         // 首先判断是否空栈，如果是，则返回 NULL
    p = top;                              // p 指向原栈的栈顶结点
    (*e) = p->data;                       // 取出原栈的元素送 (*e)
    top = top->next;                      // 删除原栈的栈顶结点
    free(p);                              // 释放原栈顶结点的空间
    return top;                           // 返回新的栈顶指针 top
}
```
## 3.2 队列

### 3.2.1 队列的基本概念

队列也是插入和删除操作位置受限的线性表，只允许在表的一端删除元素，在另一端插入元素。

与队列有关的概念包括以下几个：

- **空队列**：不含元素的队列。
- **队首**：队列中只允许删除元素的一端。其一般称为 `head`、`front`。
- **队尾**：队列中只允许插入元素的一端。其一般称为 `rear`、`tail`。
- **队首元素**：处于队首的元素。
- **队尾元素**：处于队尾的元素。
- **进队**：插入一个元素到队列中。其也称为入队。
- **出队**：从队列中删除一个元素。

与栈的元素进出原则不同，队列的元素进出原则是“先进先出”（First In First Out, FIFO）。队列的别名是“先进先出”表、FIFO 表、queue 等。

队列的进队是指将新元素插入队尾，出队是指将队首元素删除。最常见的一个实际例子是排队买票。买票队伍就相当于一个队列，新来的人只能排在后面，买完票的人就从队伍前面离开。

### 3.2.2 队列的抽象数据类型

队列的抽象数据类型如下：

```plaintext
ADT Queue
{
    数据对象：D = {a_i | a_i ∈ ElemSet, i = 1, 2, ..., n, n ≥ 0}
    数据关系：R1 = {<a_{i-1}, a_i> | a_{i-1}, a_i ∈ D, i = 2, ..., n}，其中 a_1 端为队首，a_n 端为队尾
    基本操作：
        InitQueue(&Q)          // 初始化队列 Q
        DestroyQueue(&Q)       // 销毁队列 Q
        ClearQueue(&Q)         // 清空队列 Q
        QueueLength(Q)         // 求队列 Q 的长度
        EnQueue(&Q, e)         // 将 e 插入队列 Q 的尾端
        DeQueue(&Q, &e)        // 取走队列 Q 的队首元素，放入 e
        GetHead(Q, &e)         // 读取队列 Q 的队首元素，放入 e
        QueueEmpty(Q)          // 判断队列 Q 是否为空队列
}
End ADT
```

### 3.2.3 顺序队列的基本运算及实现

下面在分析循环队列特性的基础上，说明顺序循环队列的入队算法和出队算法。首先，对队列的结构类型 `SeQueue` 进行如下定义。

```cpp
#define MAXLENGTH 100
typedef struct {
    ElemType elem[MAXLENGTH];
    int front, rear;
} SeQueue;
SeQueue Q;  // 定义结构变量 Q 表示队列
```

其中定义 `MAXLENGTH` 为 100，即分配给队列的存储空间为可保存 100 个元素的存储单元；这里采取静态分配的顺序存储方式，用一维数组来定义数据类型；两个标识 `front` 和 `rear` 分别指向队首结点和队尾结点后的一个空单元；队列$Q$被定义为 `SeQueue` 类型。

#### 例 3-9：设计循环队列进队算法 `En_Queue`

假设用$Q$表示顺序队列，头指针 `front` 指向队头元素，`rear` 指向尾元素的后一个空位，$e$为进队元素。首先要判断队列是否为满队列，如果队列已满，则退出；如果队列不是满队列，则插入新元素；`rear` 往后移动一个位置；由于是循环队列，还需对分配的存储空间大小取余。

```cpp
Status En_Queue(SeQueue &Q, Elemtype e) {
    if ((Q.rear + 1) % MAXLENGTH == Q.front) {
        return ERROR;  // 若 Q 已满，退出
    }
    Q.elem[Q.rear] = e;  // 装入新元素 e
    Q.rear++;            // 尾指针后移一个位置
    Q.rear = Q.rear % MAXLENGTH;  // 为循环队列
    return OK;
}
```

#### 例 3-10：设计循环队列出队算法 `De_Queue`

用$Q$表示顺序队列，头指针 `front` 指向队头元素，`rear` 指向尾元素的后一个空位。

首先判断队列是否为空队列，如果队列为空，则退出，否则，取出队头元素，并放在$e$中。`front` 往后移动一个位置，并且由于是循环队列，因此 `front` 往后移动时还需对存储空间大小取余。

```cpp
Status De_Queue(SeQueue &Q, Elemtype &e) {
    if (Q.front == Q.rear) {
        return ERROR;  // Q 为空队列，退出
    }
    e = Q.elem[Q.front];  // 取出队头元素，放在 e 中
    Q.front = (Q.front + 1) % MAXLENGTH;  // 循环后移到一个位置
    return OK;
}
```

### 3.2.4 链式队列的基本运算及实现

存放元素的结点类型定义（此定义与单链表结点类型定义一致，其包括数据域和指针域）如下。

```cpp
typedef struct Qnode {
    ElemType data;      // 数据域 data 为抽象元素类型
    struct Qnode *next; // 指针域 next 为指针类型
} Qnode, *QueuePtr;     // Qnode 为结点类型；QueuePtr 为指向 Qnode 的指针类型
```

由头、尾指针组成的结点类型定义如下。

```cpp
typedef struct {
    Qnode *front; // 头指针
    Qnode *rear;  // 尾指针
} LinkQueue;      // 链式队列类型
```

#### 例 3-11：设计生成空队列算法，即初始化队列算法 `InitQueue`

```cpp
#define LENGTH sizeof(Qnode)
void InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = (QueuePtr)malloc(LENGTH);  // 生成表头结点
    Q.front->next = NULL;                         // 表头结点的 next 为空指针
}
```

#### 例 3-12：设计队列插入算法

根据以上的分析过程，编写出插入元素$e$的算法 `EnQueue` 如下。

```cpp
Status EnQueue(LinkQueue &Q, ElemType e) {
    Qnode *p;
    p = (Qnode *)malloc(LENGTH);  // 生成新元素结点
    if (!p) return ERROR;
    p->data = e;                   // 装入元素 e
    p->next = NULL;                // 设置为队尾结点
    Q.rear->next = p;              // 插入新结点
    Q.rear = p;                    // 修改尾指针
    return OK;
}
```

主函数可以调用 `InitQueue` 函数进行初始化，然后调用 `EnQueue` 函数进行元素的插入。例如定义一个队列 `que`，初始化后可插入一个新元素 10。

```cpp
int main() {
    LinkQueue que;  /* 定义一个队列 */
    InitQueue(que);
    EnQueue(que, 10);
    return 0;
}
```

下面分析删除操作，注意队列删除元素是删除队首元素。如果队列有两个或者两个以上的结点，只需要变化表头结点的指针即可完成删除操作。表头结点的指针指向队首结点，定义一个指针$p$指向此结点 “$p = Q.front->next$”，然后为删除队首结点变化表头结点的指针，表头结点的指针指向首结点的后继结点 “$Q.front->next = p->next$”，最后释放点原首结点所占据的空间，即 “$free(p)$” 。

如果队列只有一个结点，除了变化表头结点的指针，还需考虑队尾指针（因为队列只有一个结点，删除该结点后的队列就是空队列）。具体操作方法为：首先删除首结点 “$Q.front->next = p->next$”，然后释放首结点的空间 “$free(p)$”，再将尾指针指向表头结点，表明队列是一个空队列 “$Q.rear = Q.front$” 。

#### 例 3-13：设计队列删除算法

根据上述分析，编写出删除队列元素$e$的算法 `DeQueue` 如下。

```cpp
Status DeQueue(LinkQueue &Q, ElemType &e) {
    if (Q.front == Q.rear) {
        return ERROR;  // 若原队列为空
    }
    Qnode *p;
    p = Q.front->next;  // p 指向队头结点
    e = p->data;        // 取出元素，e 指向它
    Q.front->next = p->next;  // 删除队头结点
    if (Q.rear == p) {
        Q.rear = Q.front;  // 修改尾指针
    }
    free(p);               // 释放被删除结点的空间
    return OK;             // 返回出队后的 Q
}
```
# 第4章 字符串、多维数组与广义表
## 4.1 字符串

### 4.1.1 字符串的定义

字符串是由零个或者多个字符组成的有限序列，一般记为：

$$
S = "a_1 a_2 \cdots a_n" \quad (n \geq 0)
$$

其中：
-$S$是字符串的名称；
- 双引号 ("") 括起来的字符序列为串值，双引号本身不属于串值，只是代表串的起止标记；
- 序列中的$a_i \, (1 \leq i \leq n)$可以是字母、数字和其他字符，$i$称为字符$a_i$在该串中的位置；
-$n$表示串的长度，即串中包含的字符个数；
- 当$n = 0$时，称为空串（null string）；仅含若干个空格的串称为空格串。

#### 抽象数据类型（ADT）定义

```plaintext
ADT String
{
    数据对象：D = {a_i | a_i ∈ 字符集合, i = 1, 2, ..., n, n ≥ 0}
    数据关系：R1 = {<a_{i-1}, a_i> | a_{i-1}, a_i ∈ D, i = 2, ..., n}
    基本操作：
        StrAssign(&T, S)       // 根据串常量 S，创建串 T
        StrDestroy(&S)         // 销毁串 S
        StrCopy(&T, S)         // 将串 S 复制到串 T
        StrLength(S)           // 求串 S 的长度
        StrComp(S, T)          // 比较串 S 和串 T 的值
        StrSub(&T, S, pos, len)// 从串 S 位置 pos 取长度为 len 的子串赋予 T
        StrConcat(&T, S)       // 将串 S 的字符连接到 T 的尾部
        StrIndex(S, T, pos)    // 求串 T 在 S 中位置 pos 后第一次出现的位置
        StrInsert(&T, S, pos)  // 将串 S 插入串 T 的第 pos 个字符之前
        StrDelete(&S, pos, len)// 将串 T 位置 pos 开始的长度为 len 的子串删除
}
End ADT
```

#### 例 4-1：串替换算法

```cpp
void StrReplace(SeqString* S, SeqString T, SeqString V)
{
    int i = 1, len_T = StrLength(T), len_V = StrLength(V);
    while ((i = StrIndex(*S, T, i)) != 0)
    {
        StrDelete(S, i, len_T);
        StrInsert(S, V, i);
        i = i + len_V;
    }
}
```

### 4.1.2 字符串的存储结构及其基本运算的实现

与线性表类似，通常字符串也有顺序存储和链式存储两大类，对应的有顺序串和链串。而顺序存储又可以细分为静态存储分配和动态存储分配，这样字符串的存储结构就可以分为 3 类。

#### 1. 静态存储分配的顺序串

该存储结构就是通过字符数组的方式分配连续的存储空间来保存串值。数组的存储空间是在编译时确定的，并且运行时不能改变连续空间的大小，这样能表示的字符串长度最大值就固定下来了，所以这种形式表示的串也称为串的定长顺序存储表示。例如：

```cpp
#define MAXLENGTH 256
typedef unsigned char SeqString[MAXLENGTH];
SeqString S;
```

##### （1）串插入操作 `StrInsert(&T, S, pos)`

假定$T$和$S$都是类型为 `SeqString` 的串变量，现要将串$S$插入串$T$的第$pos$个位置之前。首先验证插入点是否正确，$T$是一个长度为$T[0]$的串，插入位置$pos$的取值范围应该是$1 \sim T[0] + 1$；接着判断$T$的空闲空间是否足够大，能否再增加$S[0]$个字符；如果这些条件都满足，此时就将$T$中从第$pos$个字符开始直到最后一个字符区间内的所有字符向后移动$S[0]$个字符位置，最后将$S$的串值从$T$的位置$pos$开始复制到$T$中，完成插入操作。

**例 4-2：串插入算法**

```cpp
status StrInsert(SeqString T, SeqString S, int pos)
{
    if (pos < 1 || pos > T[0] + 1) return ERROR;
    if (T[0] + S[0] >= MAXLENGTH) return ERROR;
    int j;
    for (j = T[0]; j >= pos; j--)
        T[j + S[0]] = T[j];
    for (j = 0; j < S[0]; j++)
        T[pos + j] = S[j + 1];
    T[0] = T[0] + S[0];
    return OK;
}
```

##### （2）串比较操作 `StrComp(S, T)`

串比较操作是将两个字符串进行比较，即：如果$S > T$，返回一个正整数；如果$S$与$T$相等，返回 0；否则返回负整数。该操作算法实现时，首先需要将$S$和$T$对应位置上的字符进行比较，这时需要计算$S[0]$和$T[0]$间的较小值并赋予$m$，表示$S$和$T$在位置$1 \sim m$上的字符可进行比较，如果在位置$i$上出现不相等的情况，即$S[i] \neq T[i]$时，返回$S[i] - T[i]$，结果为正就表示$S > T$，为负表示$S < T$。如果位置$1 \sim m$上的字符都对应相等，则两个串相等，返回 0；第二种情况是$S[0] > T[0]$，表示$T$中的字符都比较过了，而$S$中还有若干个字符，在$T$中没有对应位置的字符可进行比较，所以$S > T$，返回正整数；剩下的第三种情况就是$S[0] < T[0]$，需要返回一个负整数，这 3 种情况很容易合并在一起，返回值用$S[0] - T[0]$即可。

**例 4-3：串比较算法**

```cpp
int StrComp(SeqString S, SeqString T)
{
    int i, m = S[0] < T[0] ? S[0] : T[0];
    for (i = 1; i <= m; i++)
        if (S[i] != T[i]) return S[i] - T[i];
    return S[0] - T[0];
}
```

##### 静态存储分配的顺序串还可以沿用线性表中的静态存储分配的顺序表，其定义如下：

```cpp
typedef struct {
    unsigned char ch[MAXLENGTH];
    int length;
} SeqString;
```

这个类型定义用 `SeqString` 说明变量表示的串，最大长度为 256。两种定义方式只是形式上的差异，本质上是相同的。

#### 2. 动态存储分配的顺序串

由于定长顺序串的空间是在编译阶段就确定的，运行阶段不能够改变空间大小，这样就会出现一些常见的问题：预留空间太大、串长较小而造成空间的浪费；如果空间不是足够大，在做插入、联接操作时可能会舍弃超长部分，造成数据的丢失。为此，我们可以考虑采用线性表中动态存储分配的顺序表，利用动态分配函数 `malloc`，根据串长来申请分配串需要的空间，并用 `free` 函数来释放串空间。通过这种方式，就能有效地避免前述静态存储分配顺序串的缺陷。由于使用 `malloc` 函数申请内存空间时是在程序运行时逻辑空间中的堆空间（heap space）进行的，所以动态存储分配的顺序串也被称为串的堆存储分配表示。其数据类型的定义如下：

```cpp
typedef struct {
    unsigned char *ch;
    int length;
} HString;
```

##### （1）串赋值操作 `StrAssign(&T, S)`

假定$T$是类型为 `HString` 的串，$S$是以 “\0” 结束的串常量。赋值操作后，$T$原来的值会被替换掉，所以操作前需要判断$T$是否为空串，非空串就需要释放原有串的空间；接着计算$S$的串长，根据$S$串长为$T$分配存放串值的空间，并将$S$的串值复制到$T$中，修改$T$的 `length` 属性，完成串赋值操作。

**例 4-4：串赋值算法**

```cpp
status StrAssign(HString *T, char *S)
{
    int i;
    for (i = 0; *(S + i); i++);
    char *new_ch;
    if (!i) new_ch = NULL;
    else if (!(new_ch = (unsigned char *)malloc(i * sizeof(char))))
        return OVERFLOW;
    if (T->ch) free(T->ch);
    T->ch = new_ch;
    T->length = i;
    for (i = 0; i < T->length; i++)
        T->ch[i] = S[i];
    return OK;
}
```

##### （2）求子串操作 `StrSub(&T, S, pos, len)`

假定$T$和$S$是类型为 `HString` 的串，现要从$S$的位置$pos$取长度为$len$的子串赋予$T$。首先要判断$pos$是否为$S$中一个正确的位置，以及从位置$i$开始，在$S$中是否能取到一个长度为$len$的子串。如果正确，就从$S$位置$pos$开始读取$len$个字符得到子串，并将其赋予$T$。

**例 4-5：求子串算法**

```cpp
status StrSub(HString *T, HString S, int pos, int len)
{
    if (pos < 1 || pos > S.length || len < 0 || S.length - pos + 1 < len)
        return ERROR;
    char *new_ch;
    if (!len) new_ch = NULL;
    else if (!(new_ch = (unsigned char *)malloc(len * sizeof(char))))
        return OVERFLOW;
    if (T->ch) free(T->ch);
    T->ch = new_ch;
    T->length = len;
    int j;
    for (j = 0; j < len; j++)
        T->ch[j] = S.ch[pos + j - 1];
    return OK;
}
```

##### （3）串联接操作 `StrConcat(&T, S)`

假定$T$和$S$是类型为 `HString` 的串，如果$S$是一个非空串，就需要为$T$重新分配一个更大的空间，将$T$和$S$联接，结果保存在$T$。

**例 4-6：串联接算法**

```cpp
status StrConcat(HString *T, HString S)
{
    if (S.length) {
        int len = T->length + S.length;
        char *new_ch;
        if (!(new_ch = (unsigned char *)realloc(T->ch, len * sizeof(char))))
            return OVERFLOW;
        T->ch = new_ch;
        int i;
        for (i = 0; i < S.length; i++)
            T->ch[T->length + i] = S.ch[i];
        T->length = len;
        return OK;
    }
}
```

#### 3. 串的链式存储

与线性表类似，串也可以采用链式存储结构来表示，如使用单链表，串的链式存储结构也称为链串，如图 4.3(a) 所示。使用链式存储结构能方便地进行插入与删除等操作，且能避免大量移动字符。链式存储结构类型定义如下：

```cpp
typedef struct node {
    char data;
    struct node *next;
} LinkStrNode, *LinkString;
```

在链式存储结构中，首先引入一个存储密度的概念，其公式为：

$$
\text{存储密度} = \frac{\text{串值所占存储字节数}}{\text{实际分配存储字节数}} \times 100\%
$$

如果在一个结点存放 1 个字符，占 1 字节，在 32 位系统中指针需要占 4 字节，所以链串的存储密度为 20%，存储密度是相当低的；如果是 64 位系统，存储密度会更低。为了提高存储密度，这里可以考虑在一个结点中存放多个字符，比如放 4 个字符，如图 4.3(b) 所示。通常将一个结点数据域存放的字符数定义为结点大小。对于一个非空串，由于串的长度不一定正好是结点大小的整数倍，因此在最后一个结点需要填充特殊的符号，代表串的结束。对于结点大小大于 1 的链式存储，其类型定义的一般形式如下：

```cpp
#define NODESIZE 4
typedef struct node {
    char data[NODESIZE];
    struct node *next;
} LinkStrNode, *LinkString;
```

### 4.1.3 字符串的模式匹配算法

#### 子串定位操作 StrIndex(S, T, pos)

子串定位操作 StrIndex(S, T, pos) 的目的是求串$T$在串$S$中第$pos$个字符后第一次出现的位置。此操作应用非常广泛，是较为重要的串操作之一。在各种文本处理系统中，一个好的定位算法能够极大地提升系统的响应性能。

子串定位操作也称为串的模式匹配，其中主串$S$称为目标串，子串$T$称为模式串。假定目标串$S$的长度为$n$，模式串$T$的长度为$m$，$S$和$T$分别表示如下。在实际应用中，通常$m$远小于$n$，即$m \ll n$。

$$
S = "s_1 s_2 \cdots s_n" \quad T = "t_1 t_2 \cdots t_m"
$$

串模式匹配操作就是在目标串$S$中找到一个与模式串$T$相等的子串$"s_i s_{i+1} \cdots s_{i+m-1}"$，这里$i$取符合条件的最小值（$pos \leq i \leq n-m$）。如果存在这样的$i$，表示匹配成功；否则表示匹配失败，模式串$T$不是目标串$S$的子串。

---

#### 1. 朴素的模式匹配算法

朴素的模式匹配算法是一种简单的字符串匹配方法，其核心思想是逐字符比较目标串和模式串，直到找到匹配或遍历完整个目标串。

##### 示例：朴素模式匹配算法（例 4-7）

```cpp
int StrIndex(SeqString S, SeqString T, int pos)
{
    int i, j;
    for (int i = pos, j = 1; i <= S[0] - T[0] + 1; i++, j++) {
        if (S.ch[i] != T.ch[j]) {
            i = i - j + 1; // 回溯到本次匹配起点，准备下次匹配
            j = 0;
        } else if (j == T[0]) { // 匹配成功，返回本次匹配起始位置
            return i - j + 1;
        }
    }
    return 0; // 匹配失败
}
```

**算法分析：**
- 时间复杂度：最坏情况下，朴素算法的时间复杂度为$O(n \cdot m)$，因为每次不匹配时需要回溯。
- 空间复杂度：$O(1)$，仅使用常量级别的额外空间。

---

#### 2. KMP 算法（Knuth-Morris-Pratt Algorithm）

KMP 算法是一种高效的字符串匹配算法，通过预处理模式串来避免不必要的回溯，从而显著提高匹配效率。

##### （1）KMP 算法的核心思想

KMP 算法的核心是利用模式串本身的性质，构建一个部分匹配表（Next 数组），用于指导匹配过程中如何高效地移动指针，避免不必要的回溯。

###### 部分匹配表（Next 数组）
- Next 数组的定义：对于模式串$$T = "t_1 t_2 \cdots t_m"$$Next 数组记录了每个位置$j$的最长公共前后缀长度，即：
$$
  Next[j] = \max\{k | 0 \leq k < j \text{ 且 } T[1..k] = T[j-k+1..j]\}
$$
- Next 数组的作用：当匹配失败时，根据 Next 数组的值，可以快速确定模式串的下一个匹配位置，而不需要重新从头开始匹配。

###### 构建 Next 数组的算法
- 初始化：$Next[1] = 0$
- 对于$j = 2$到$m$：
  - 如果$T[j] = T[k+1]$，则$Next[j] = k + 1$
  - 否则，令$k = Next[k]$，重复上述步骤，直到找到匹配或$k = 0$

##### （2）KMP 算法的实现

###### 示例：KMP 算法实现

```cpp
// 构建 Next 数组
void GetNext(char *T, int next[]) {
    int m = strlen(T);
    next[0] = 0; // 初始化为0
    int k = 0;
    for (int j = 1; j < m; j++) {
        while (k > 0 && T[j] != T[k]) { // 注意这里k的条件变为k > 0
            k = next[k - 1];
        }
        if (T[j] == T[k]) {
            k++;
        }
        next[j] = k;
    }
}

// KMP 算法
int KMPMatch(char *S, char *T) {
    int n = strlen(S); // 主串长度
    int m = strlen(T); // 模式串长度
    int next[m];       // next数组
    GetNext(T, next);  // 构建Next数组

    int i = 0, j = 0; // i是主串指针，j是模式串指针
    while (i < n && j < m) {
        if (j == 0 || S[i] == T[j]) { // 当j为0时，表示模式串的指针回到了起始位置，或者当前字符匹配成功
            i++;
            j++;
        } else {
            j = next[j - 1]; // 如果不匹配，j回退到next[j-1]的位置
        }
    }

    if (j == m) {
        return i - j; // 匹配成功，返回匹配起始位置
    } else {
        return -1; // 匹配失败
    }
}
```

##### （3）KMP 算法的时间复杂度

- **预处理阶段（构建 Next 数组）：** 时间复杂度为$O(m)$，其中$m$是模式串的长度。
- **匹配阶段：** 时间复杂度为$O(n)$，其中$n$是目标串的长度。

因此，KMP 算法的总时间复杂度为$O(n + m)$，比朴素算法的$O(n \cdot m)$显著提高。

---

#### 总结

- **朴素算法：** 简单易懂，但效率较低，时间复杂度为$O(n \cdot m)$。
- **KMP 算法：** 高效，通过预处理模式串避免不必要的回溯，时间复杂度为$O(n + m)$。

KMP 算法在实际应用中具有重要意义，尤其是在需要频繁进行字符串匹配的场景中，如文本编辑器、搜索引擎等。

## 4.2 多维数组

前面章节所介绍的各种线性结构都有一个共同的特征：数据元素具有原子性，即每个数据元素的值不能再进一步分解。本节重点要讨论的多维数组可以被看成是线性表的一种扩展，即线性表中的数据元素本身也可以是一种数据结构，如是同质的线性表，从整体来看，它们就是一个数据结构的嵌套形式。

几乎在所有的程序设计语言中都把数组设置成一种固有类型，通过语法规则提供对数组的支持，例如，在 C 语言中可以定义符合 C 语言语法规则的多维数组，C 编译程序为数组的全部元素分配一片连续的存储单元，我们可以通过下标变量形式或寻址公式对数组元素进行随机访问。在数据结构课程中，将系统、全面地介绍数组这个抽象数据类型的逻辑特征、存储结构，并重点讨论数组元素的存储和访问方式。数组存储空间的地址可以是连续的，也可以是不连续的；数组存储空间可以保存全部数组元素，也可以根据数组的实际情况对数组进行压缩存储，只保存部分数据元素；对数组元素的访问可能是随机访问，也可能只能顺序访问。

### 4.2.1 多维数组概念的引入

```
ADT Array {
    数据对象: D={a_{i_1i_2\cdots i_j\cdots i_n}|a_{i_1i_2\cdots i_j\cdots i_n}\in ElemSet}
        i_j 是第 j 维的下标, 1\leqslant i_j\leqslant b_j
        1\leqslant j\leqslant n, b_j 是第 j 维的长度
    数据关系: R={R_1,R_2,\cdots,R_n}
        R_j={<a_{i_1i_2\cdots i_j\cdots i_n},a_{i_1i_2\cdots i_{j+1}\cdots i_n}>是第 j 维 b_j 个元素的关系}
        1\leqslant j\leqslant n, 1\leqslant i_j\leqslant b_j-1, b_j 是第 j 维的长度
    基本操作:
        ArrayInit(&A,dim,bounds[])      // 初始化 dim 维数组 A, 每维长度 bounds
        ArrayDestroy(&A)                // 销毁数组 A
        ArrayAssign(&A, e, index[])     // 将 e 赋予数组 A 下标为 index 的元素
        ArrayValue(A, &e, index [])     // 将数组 A 下标 index 的元素值赋予 e
}
End ADT
```

### 4.2.2 多维数组的顺序存储

第一种方式称为行序优先，即将二维数组的元素逐行地保存在连续存储空间中，$a_{ij}$的地址计算公式为：

$$
LOC(i,j)=b+((i-1)\times n+j-1)L=LOC(1,1)+((i-1)\times n+j-1)L
$$

第二种方式称为列序优先，即将二维数组的元素逐列地保存在连续存储空间中，$a_{ij}$的地址计算公式为：

$$
LOC(i,j)=b+((j-1)\times m+i-1)L=LOC(1,1)+((j-1)\times m+i-1)L
$$

对应顺序存储结构的数据类型定义如下。

```cpp
typedef struct {
    ElemType *base;         // 存储数组元素空间基地址
    int dim;                // 数组维数
    int *bounds;            // 每一维长度
    int *consts;            // dim 个映像函数的常数
} Array;
```

**例 4-9**: 初始化数组算法如下。

```cpp
status ArrayInit(Array *A, int dim, int bounds[]) {
    A->dim = dim;           // 确定数组维数
    if (!(A->bounds = (int *)malloc(dim * sizeof(int))))
        return OVERFLOW;
    int i;
    for (i = 0; i < dim; i++) {
        if (bounds[i] < 1) { free(A->bounds); return ERROR; }
        A->bounds[i] = bounds[i];          // 检查和保存每一维长度
    }
    if (!(A->consts = (int *)malloc(dim * sizeof(int)))) {
        free(A->bounds); return OVERFLOW;
    }
    A->consts[dim - 1] = 1;
    for (i = dim - 2; i >= 0; i--) {
        A->consts[i] = A->consts[i + 1] * A->bounds[i + 1];
    }
    A->base = (ElemType *)malloc(A->consts[0] * A->bounds[0]); // 分配元素空间
    if (!A->base) {
        free(A->bounds); free(A->consts); return OVERFLOW;
    }
    return OK;
}
```

对数组进行赋值操作时，根据参数中给出的数组元素下标 `index`，利用数组$A$中保存的各维大小和映射函数常量，按照地址公式计算出元素的地址，将元素$e$写到对应的单元中。

**例 4-10**: 数组元素赋值算法如下。

```cpp
status ArrayAssign(Array *A, ElemType e, int index[]) {
    ElemType* addr = A->base; // 指向数组首地址
    int i;
    for (i = 0; i < A->dim; i++) {
        // 根据各维下标，利用地址公式计算数组元素地址 addr
        if (index[i] < 1 || index[i] > A->bounds[i]) return ERROR;
        addr += A->consts[i] * (index[i] - 1);
    }
    *addr = e;
    return OK;
}
```

### 4.2.3 矩阵的压缩存储

#### 1. 特殊矩阵的压缩存储

##### （1）对称矩阵

$$
k =
\begin{cases}
\frac{i(i-1)}{2} + j & i \geqslant j \\
\frac{j(j-1)}{2} + i & i < j
\end{cases}
$$

##### （2）三对角矩阵

$$
k =
\begin{cases}
2i + j - 2 & |i - j| \leqslant 1 \\
0 & \text{其他}
\end{cases}
$$

#### 2. 稀疏矩阵的压缩存储

##### （1）三元组顺序表

以顺序存储结构来表示三元组表，得到稀疏矩阵的一种压缩存储方式，我们称这种存储方式为三元组顺序表。数据类型定义如下。

```cpp
#define MAXSIZE 10000
typedef struct {
    int i, j;               // 非零元素行、列下标
    ElemType v;             // 非零元素值
} Triple;

typedef struct {
    Triple data[MAXSIZE + 1];
    int m, n, t;            // 稀疏矩阵的行数、列数和非零元素个数
} TriSeqList;
```

**例 4-11**: 转置矩阵算法如下。

```cpp
TriSeqList TransMat(TriSeqList M) {
    TriSeqList N;
    N.m = M.n; N.n = M.m; N.t = M.t;
    if (M.t) {
        int q = 1, col, p;
        for (col = 1; col <= M.n; col++)
            for (p = 1; p <= M.t; p++)
                if (M.data[p].j == col) {
                    N.data[q].j = M.data[p].i;
                    N.data[q].i = M.data[p].j;
                    N.data[q++].v = M.data[p].v;
                }
    }
    return N;
}
```

**例 4-12**: 快速转置矩阵算法如下。

```cpp
TriSeqList FastTransMat(TriSeqList M) {
    TriSeqList N; int num[M.n], cpot[M.n];
    N.m = M.n; N.n = M.m; N.t = M.t;
    if (M.t) {
        int col, t, p, q;
        for (col = 1; col <= M.n; col++) num[col] = 0;
        for (t = 1; t <= M.t; t++) ++num[M.data[t].j];
        cpot[1] = 1;
        for (col = 2; col <= M.n; col++) cpot[col] = cpot[col - 1] + num[col - 1];
        for (p = 1; p <= M.t; ++p) {
            col = M.data[p].j;
            q = cpot[col];
            N.data[q].j = M.data[p].i;
            N.data[q].i = M.data[p].j;
            N.data[q].v = M.data[p].v;
            ++cpot[col];
        }
    }
    return N;
}
```

综合算法的各个处理阶段，算法的时间复杂度为$O(M.n + M.t)$。

##### （2）十字链表

以链式存储结构来表示三元组表，得到稀疏矩阵的另一种压缩存储方式。由于二维数组元素有行关系和列关系，因此三元组的结点需要两个指针来维护这两个关系，于是有了带两个指针的三元组结点。

十字链表的数据类型定义如下。

```cpp
typedef struct TriNode {
    int i, j;
    ElemType v;
    struct TriNode *right, *down; // 行列关系指针
} TriNode, *TriLink;

typedef struct {
    TriLink *rhead, *chead;       // 行列头指针数组
    int m, n, t;                  // 稀疏矩阵的行数、列数和非零元素个数
} CrossLinkList;
```

**例 4-13**: 基于十字链表的转置矩阵算法如下。

```cpp
CrossLinkList TransMat_CL(CrossLinkList M) {
    CrossLinkList N;
    N.m = M.n; N.n = M.m; N.t = M.t;
    if (!(N.rhead = (TriLink *)calloc(N.m, sizeof(TriLink))))
        exit(OVERFLOW);
    if (!(N.chead = (TriLink *)calloc(N.n, sizeof(TriLink))))
        exit(OVERFLOW);
    if (M.t) {
        int row; TriLink p;
        for (row = M.m - 1; row >= 0; row--) {
            for (p = M.rhead[row]; p; p = p->right) {
                TriLink r, q = (TriNode *)malloc(sizeof(TriNode));
                q->i = p->j; q->j = p->i; q->v = p->v;
                q->right = N.rhead[q->i - 1]; N.rhead[q->i - 1] = q;
                q->down = NULL;
                if (N.chead[q->j - 1] == NULL)
                    N.chead[q->j - 1] = q;
                else {
                    TriLink r;
                    for (r = N.chead[q->j - 1]; r->down; r = r->down);
                    r->down = q;
                }
            }
        }
    }
    return N;
}
```
# 第 5 章 树与二叉树

## 5.1 实际应用中的树

## 5.2 树的逻辑结构

在树中，数据元素对应于结点（Node），数据元素间的逻辑关系对应于结点间一对多的层次关系。下面基于树的定义来描述结点间的逻辑关系，刻画树的逻辑结构。

### 5.2.1 树的定义与基本术语

树（Tree）是由$n$($n \geqslant 0$) 个结点构成的有限集合，可表示为$T_n$。当$n = 0$时，$T$为空树；而任何非空树必满足：

1. 有唯一的特定结点，其称为树$T$的根（Root）；
2. 当$n > 1$时，$T$中除根之外的$n-1$个结点分为$m$($m > 0$) 个互不相交的有限集$T_1, T_2, \cdots, T_m$，其中每个集合$T_i$($1 \leqslant i \leqslant m$) 又是一棵树，且称为根的子树（SubTree）。

#### 表 5.1 线性结构与树结构的区别

| 线性结构                          | 树结构                           |
|-----------------------------------|----------------------------------|
| 第一个数据元素                     | 根结点                           |
| （无前驱）                         | （无双亲）                       |
| 最后一个数据元素                   | 多个叶子结点                     |
| （无后继）                         | （无孩子）                       |
| 其他数据元素（一个直接前驱、一个直接后继） | 其他结点                         |
|                                     | （一个双亲、多个孩子）           |

### 5.2.2 树的抽象数据类型定义

与线性表类似，树的主要操作可以划分为 3 类：查找类、插入类与删除类。查找类包括判断树是否为空、求树的深度、求根的值、求给定结点的值、求给定结点的双亲结点、求给定结点的某个孩子结点、求给定结点的某个兄弟结点、遍历树等；插入类操作包括树的初始化、树的创建、子树的插入等；删除类操作包括树的销毁、删除子树等。

树中表示的数据对象是某种具有相同特性数据元素的集合。树的抽象数据类型定义如下。

```cpp
ADT Tree
{
    数据对象: D = {a_i | a_i ∈ ElemSet, i = 1, 2, ..., n, n ≥ 0}
    数据关系: 若 D 非空，则 D 中存在唯一数据元素对应于根结点，且所有元素之间具有一对多的层次关系
    基本操作:
        InitTree(&T)               // 初始化，构造空树 T
        CreateTree(&T, definition) // 根据树的定义信息 definition 创建树 T
        DestroyTree(&T)            // 若 T 存在，则销毁树 T
        TreeEmpty(T)               // 若 T 存在且为空返回 TRUE，否则返回 FALSE
        TreeDepth(T)               // 若 T 存在，返回其深度
        Value(T, cur_e)            // 若树 T 存在，返回 T 中当前结点 cur_e 的值
        Assign(T, cur_e, value)    // 若树 T 存在，当前结点 cur_e 赋值为 value
        Parent(T, cur_e)           // 若树 T 存在，返回非根结点 cur_e 的双亲结点
        LeftChild(T, cur_e)        // 若树 T 存在，返回结点 cur_e 的最左孩子结点
        RightSibling(T, cur_e)     // 若树 T 存在，返回结点 cur_e 的右兄弟结点
        InsertChild(&T, &p, i, c)  // 将以 c 为根的树插入 T 且作为结点 p 的第 i 棵子树
        DeleteChild(&T, &p, i)     // 若树 T 存在，删除 T 中结点 p 的第 i 棵子树
        TraverseTree(T, Visit())   // 用 Visit() 结点处理函数对树 T 进行遍历
}
End ADT
```

## 5.3 树的存储结构

### 5.3.1 双亲表示法

由此，树的双亲表示法的存储结构定义如下。

```cpp
#define MAX_TREE_SIZE 100
typedef struct PTNode {
    TElemType data;          // data 为结点数据元素
    int parent;              // parent 为该结点的双亲位置，用数组下标表示
} PTNode;
typedef struct {
    PTNode nodes[MAX_TREE_SIZE];
    int r, n;                // 根结点位置，树中结点个数
} PTree;
```

在树的双亲存储结构中，易于求当前结点的双亲结点，但是要求当前结点的孩子结点或兄弟结点，则需要遍访数组全部元素。对某些应用而言，其效率不高。

### 5.3.2 孩子表示法

树的孩子链表表示法的存储结构定义如下。

```cpp
typedef struct CTNode {
    int child;               // 孩子结点结构
    struct CTNode *next;
} *ChildPtr;
typedef struct {
    TElemType data;          // data 为结点数据元素
    ChildPtr firstchild;     // 孩子链表头指针
} CTBox;
typedef struct {
    CTBox ndes[MAX_TREE_SIZE];
    int r, n;                // 根结点位置，树中结点个数
} CTree;
```

### 5.3.3 孩子兄弟表示法

树的孩子兄弟表示法的存储结构定义如下。

```cpp
typedef struct CSNode {
    TElemType data;          // data 为结点数据元素
    struct CSNode *firstchild, *nextsibling;
} CSNode,*CSTree;
CSTree root;                 // 树根指针
```
## 5.4 二叉树的逻辑结构

### 5.4.1 二叉树的定义

（1）每个结点至多有两棵子树，因此在二叉树中不存在度大于 2 的结点。

（2）二叉树的子树有左、右之分，且其次序不能任意颠倒。

根据二叉树的上述特点，二叉树可分为 5 种形态：空二叉树、仅有根结点的二叉树、右子树为空的二叉树、左子树为空的二叉树、根的左右子树均非空的二叉树。

### 5.4.2 二叉树的性质

#### 性质 5.1
在二叉树的第$i$层上至多有$2^{i-1}$个结点 ($i \geqslant 1$)。

#### 性质 5.2
在深度为$k$的二叉树中，最多有$2^k - 1$个结点。

#### 性质 5.3
在一棵非空二叉树中，若其叶子结点数为$n_0$，度为 2 的结点数为$n_2$，则有：
$$
n_0 = n_2 + 1
$$

##### 满二叉树（Full Binary Tree）
对于深度为$k$的二叉树，如果其结点数为$2^k - 1$，即达到最大值，则称其为满二叉树。图 5.15 分别为深度从 1 到 4 的 4 棵满二叉树。

满二叉树的特点有：
1. 叶子只出现在最下层；
2. 只含度为 0 与 2 的结点。

##### 完全二叉树（Complete Binary Tree）
一棵深度为$k$的二叉树，对其全部结点从根开始，按层序从上至下、从左至右进行连续编号，如果编号为$i$($1 \leqslant i \leqslant n$) 的结点与同深度的满二叉树中编号为$i$($1 \leqslant i \leqslant n$) 的结点在二叉树中的位置完全相同，则称这棵二叉树为完全二叉树。

显然，一棵满二叉树一定是一棵完全二叉树。


完全二叉树的特点有：
1. 叶子结点只可能出现在最下两层，如果删除最下层的叶子结点，则变成满二叉树；
2. 对任意结点$i$，其左、右子树的深度分别表示为$Lh_i$与$Rh_i$，则$|Lh_i - Rh_i| = 0$或$1$；
3. 至多有一个度为 1 的结点，且度为 1 的结点只有左孩子结点。

#### 性质 5.4
具有$n$个结点完全二叉树的深度为$\lfloor \log_2 n \rfloor + 1$。

类似地，可以证明深度也等于$\lceil \log_2 (n+1) \rceil$。

#### 性质 5.5
对一棵含$n$个结点的完全二叉树，按层序自上而下、从左至右，由 1 开始连续编号，则对序号为$i$($1 \leqslant i \leqslant n$) 的结点（称为结点$i$），有：
1. 若$i = 1$，则该结点是二叉树的根，无双亲结点；否则，结点$\left\lfloor \frac{i}{2} \right\rfloor$为其双亲结点；
2. 若$2i > n$，则结点$i$无左孩子（为叶子）结点；否则，结点$2i$为其左孩子结点；
3. 若$2i + 1 > n$，则结点$i$无右孩子结点；否则，结点$2i + 1$为其右孩子结点。
## 5.5 二叉树的存储结构

### 5.5.1 二叉树的顺序存储结构

定义给出的二叉树的有序序列定义，仿此易于给出三叉树存储结构定义。

```cpp
#define MAX_TREE_SIZE 100
typedef struct BiTNode {
    TElemType data;          // 结点数据元素
    struct BiTNode *lchild, *rchild; // 左、右孩子指针
} BiTNode;
BiTNode T[MAX_TREE_SIZE];    // 用数组表示结点
```

在实际操作时，采用何种存储结构，需要根据应用的处理需求与操作特性加以选择。

### 5.5.2 二叉树的链式存储结构

#### 性质 5.6
在$n$个结点的二叉链表中，共有$n+1$个空指针域。证明：在二叉链表中，每个结点有 2 个指针域，除去根结点之外，每个结点有一个指针指向它，故共有$n-1$个非空指针域，因此空指针域共有$2n - (n-1) = n+1$个。

下面给出二叉树的存储结构定义，仿此易于给出三叉树存储结构定义。

```cpp
#define MAX_TREE_SIZE 100
typedef struct BiTNode {
    TElemType data;          // 数据域
    struct BiTNode *lchild, *rchild; // 左、右孩子指针
} BiTNode;
BiTNode T[MAX_TREE_SIZE];    // 用数组表示结点
```

### 5.5.3 基于二叉链表的二叉树遍历

基于二叉树的存储结构，下面讨论二叉树中包括遍历等基本操作的具体实现。首先给出二叉树几种遍历的基本定义。

#### 1. 先序遍历二叉树
（1）访问根结点；
（2）先序遍历左子树；
（3）先序遍历右子树。

#### 2. 中序遍历二叉树
（1）中序遍历左子树；
（2）访问根结点；
（3）中序遍历右子树。

#### 3. 后序遍历二叉树
（1）后序遍历左子树；
（2）后序遍历右子树；
（3）访问根结点。

#### 4. 层次遍历二叉树
从二叉树的第一层（根结点）开始，从上到下逐层遍历，同一层从左到右依次访问每个结点。

---

### 5.5.4 二叉树的递归算法

#### 1. 先序遍历递归算法
由二叉树先序遍历操作的定义，易设计先序遍历递归算法。

**例 5-1：先序遍历的递归算法**

```cpp
Status PreOrderTraverse(BiTree T, Status (*Visit)(TElemType e)) {
    if (T) {
        Visit(T->data);           // 访问根结点
        PreOrderTraverse(T->lchild, Visit); // 先序遍历左子树
        PreOrderTraverse(T->rchild, Visit); // 先序遍历右子树
        return OK;
    }
}
```

假设二叉树有$n$个结点。估计上述算法的时间复杂度为$O(n)$，因为先访问根的左右子树结点均均衡分布的特殊情况，$n$充分大时可得$T(n) = O(n)$。另外，当二叉树为一般情况时，我们也可以分析推导同样的结果。递归处理需要利用系统栈，计算的空间复杂度在最坏与最好情况下分别为$O(\log n), O(n)$。

#### 2. 中序遍历递归算法
由二叉树中序遍历操作的定义，调整前面递归遍历中根结点访问与子树遍历的执行次序，便可得到二叉树中序遍历的递归算法。

**例 5-2：中序遍历的递归算法**

```cpp
Status InOrderTraverse(BiTree T, Status (*Visit)(TElemType e)) {
    if (T) {
        InOrderTraverse(T->lchild, Visit); // 中序遍历左子树
        Visit(T->data);                    // 访问根结点
        InOrderTraverse(T->rchild, Visit); // 中序遍历右子树
        return OK;
    }
}
```

#### 3. 后序遍历递归算法
由二叉树后序遍历操作的定义，调整前面递归遍历中根结点访问与子树遍历的执行次序，便可得到二叉树后序遍历的递归算法。

**例 5-3：后序遍历的递归算法**

```cpp
Status PostOrderTraverse(BiTree T, Status (*Visit)(TElemType e)) {
    if (T) {
        PostOrderTraverse(T->lchild, Visit); // 后序遍历左子树
        PostOrderTraverse(T->rchild, Visit); // 后序遍历右子树
        Visit(T->data);                      // 访问根结点
        return OK;
    }
}
```

#### 4. 层次遍历非递归算法
递归算法虽然简单、精炼，但一般其执行效率不高。因此，有时需要将其转换为非递归算法。下面介绍如何设计层次遍历的非递归算法。

二叉树中层次遍历的访问起点处于每一层的第一个结点。但遍历时需要从根结点出发，沿着指针向下一直搜索到该结点（其父结点为空）。为了在遍历过程中结点的左右子树能够回到对应对其的父结点，并进行对称地访问其对于子树中的结点，必须依次保存层次遍历中遇到的结点列。借鉴队列先进先出的原理，可以设计一种以队列为辅助工具，管理待访问结点的算法。

初始化指针$S$，根结点入队。循环以下操作：① 取队顶指针，若指针非空，从所指结点沿左分支直至最下端点，搜索路径上的各点指针依次入队$S$；② 最左下站点指针退队，访问该点，以其右子树指针入队，开始对其右子树进行遍历。

**例 5-4：层次遍历的非递归算法**

```cpp
Status LevelOrderTraverse(BiTree T, Status (*Visit)(TElemType e)) {
    BiTree Queue[MAX_TREE_SIZE]; // 定义队列
    int front = 0, rear = 0;     // 初始化队头队尾
    if (T) {
        Queue[rear++] = T;       // 根结点入队
        while (front != rear) {  // 队不空
            T = Queue[front++];  // 队首结点出队
            Visit(T->data);      // 访问队首结点
            if (T->lchild) Queue[rear++] = T->lchild; // 左子树入队
            if (T->rchild) Queue[rear++] = T->rchild; // 右子树入队
        }
        return OK;
    }
}
```

#### 5. 层次遍历算法
由二叉树层次遍历操作的可知，在进行层次遍历时，当某一层结点访问完后，需将这些结点的左右子树对下一层结点压入队列。右子节点进行访问时，即满足先访问的结点其左、右孩子也未访问过。为了在访问过程中保持层次遍历的结点顺序，我们需要设计合理的存储结构来实现这一目标。显然，队列是进行层次遍历的天然选择。

**例 5-5：层次遍历算法**

```cpp
Status LevelOrderTraverse(BiTree T, Status (*Visit)(TElemType e)) {
    BiTree Queue[MAX_TREE_SIZE]; // 定义队列
    int front = 0, rear = 0;     // 初始化队头队尾
    if (T) {
        Queue[rear++] = T;       // 根结点入队
        while (front != rear) {  // 队不空
            T = Queue[front++];  // 队首结点出队
            Visit(T->data);      // 访问队首结点
            if (T->lchild) Queue[rear++] = T->lchild; // 左子树入队
            if (T->rchild) Queue[rear++] = T->rchild; // 右子树入队
        }
        return OK;
    }
}
```

---

### 7. 创建二叉树算法

#### 5.5.5 基于层次遍历的创建二叉树算法

基于层次遍历的创建二叉树算法如下：

```cpp
Status CreateBiTree(BiTNode *&T) {
    char ch;
    // 本算法中将 TElemType 简化为 char 类型
    scanf("%c", &ch);
    if (ch == '#') T = NULL;
    else {
        if (!(T = (BiTNode *)malloc(sizeof(BiTNode)))) exit(OVERFLOW);
        T->data = ch;
        CreateBiTree(T->lchild); // 构造左子树
        CreateBiTree(T->rchild); // 构造右子树
        return OK;
    }
}
```

注意$n$个结点的二叉树中有$n+1$个空指针域，而在 `CreateBiTree` 算法中输入序列为前$n$个结点字符外，应对最后的$n+1$个空格符。

---

### 8. 销毁二叉树算法

正确创建算法表明，二叉链表是基于动态内存分配而建立的。当二叉树处理完后，我们需释放对应的二叉树，移除其二叉树的存储空间。销毁二叉树可分为 3 步：① 销毁根的左子树；② 销毁根的右子树；③ 销毁根结点。这与二叉树的后序遍历处理逻辑一致。

**例 5-7：基于后序遍历的二叉树销毁算法**

```cpp
Status DestroyBiTree(BiTNode *&T) {
    if (T) {
        DestroyBiTree(T->lchild); // 销毁左子树
        DestroyBiTree(T->rchild); // 销毁右子树
        free(T);                  // 释放根结点
        T = NULL;
    }
    return OK;
}
```

# 第 6 章 图

## 6.2 图的基本概念

### 6.2.1 图的定义和基本术语

首先，给出图的定义：一个图$G$可以定义为集合$V$和$VR$构成的二元组，记为$G = (V, VR)$。其中$V$是具有相同特征数据元素的非空集合，在图中数据元素通常称为顶点（Vertex），因此$V$称为顶点集；$VR$是顶点之间的关系集。

下面给出在后续章节中要用到的一些有关图的术语。

#### 有向图（Directed Graph）
如果顶点间的关系是有序对，且可表示为$\langle a, b \rangle \in VR$，则该有序对表示从顶点$a$到顶点$b$有一条弧（Arc）。这里$a$是弧的初始点，简称弧尾；$b$是弧的终点，简称弧头。此时，由顶点集合和弧集合组成的图称为有向图。

#### 无向图（Undirected Graph）
如果顶点间的关系是无序对，且可表示为$\{a, b\} \in VR$，则该无序对表示顶点$a$与顶点$b$的一条边（Edge）。此时，由顶点集合和边的集合组成的图称为无向图。

在无向图中，如果顶点$v_i$和$v_j$有边，就称$v_i$和$v_j$互为邻接顶点（Adjacent）；该边依附于顶点$v_i$和$v_j$，或者说该边与$v_i$和$v_j$相关联。

#### 完全图（Completed Graph）
习惯上，用$n$表示顶点的数量，$e$表示边或弧的数量。对一个有$n$个顶点的无向图，$e$的取值范围为$0 \sim n(n-1)/2$。如果任意两个顶点间都有边，则$e$可以达到最大值，一共有$n(n-1)/2$条边，这样的无向图称为完全图。

#### 有向完全图
对一个有$n$个顶点的有向图，$e$的取值范围为$0 \sim n(n-1)$。如果有向图中的任意两个顶点$v_i$和$v_j$之间有弧（从$v_i$到$v_j$有弧，同时从$v_j$到$v_i$也有弧），则一共有$n(n-1)$条弧，这样的有向图称为有向完全图。

如果图中的边或弧的数量很少，例如$e \ll n \log n$，称这类图为稀疏图，否则称为稠密图。

#### 有向网、无向网
有时，在边或弧上标注权值可以表示顶点间的距离、时间或费用等各种开销，称这样的图为网络（Network）。称带权值的有向图为有向网，带权值的无向图为无向网。

这样总共就有了 4 种类型的图：有向图、有向网、无向图和无向网。

#### 顶点的度（Degree）
与顶点$v$相关联边或弧的数量称为顶点$v$的度，记为$TD(v)$或$D(v)$。

求顶点的度需要区分无向图与有向图。在一个无向图中，与顶点$v$关联的边的数量称为顶点的度；无向图某个顶点的度表示该顶点的邻接顶点数量。

在一个有向图中，一个顶点$v$的度是由出度（Outdegree）和入度（Indegree）组成的，分别记为$OD(v)$和$ID(v)$。顶点$v$的出度等于以$v$作为弧尾的弧的数量，入度等于以$v$作为弧头的弧的数量。

#### 子图（Subgraph）
对于两个图$G = (V, VR)$和$G' = (V', VR')$，如果$V' \subseteq V$且$VR' \subseteq VR$，则称$G'$是$G$的一个子图。

#### 路径（Path）
顶点$v_i$到$v_j$有路径是指存在顶点序列$v_i, v_{i1}, v_{i2}, \cdots, v_{ik}, v_j$，其中$\langle v_i, v_{i1} \rangle$、$\langle v_{i1}, v_{i2} \rangle$、$\cdots$、$\langle v_{ik}, v_j \rangle$是图的边或$\langle v_i, v_{i1} \rangle$、$\langle v_{i1}, v_{i2} \rangle$、$\cdots$、$\langle v_{ik}, v_j \rangle$是图的弧。称第一个和最后一个顶点相同的路径为回路或环（Cycle）；不重复顶点的路径为简单路径。对于无向图，如果顶点$v_i$到$v_j$有路径，则顶点$v_i$和$v_j$是连通的。

#### 路径长度（Path Length）
对于有向图和无向图，路径长度是指路径上包含的边或弧的条数；对于有向网和无向网，路径长度是指路径上包含的边或弧上的权值之和。

#### 连通图（Connected Graph）
对于无向图，如果任意两个顶点$v_i$到$v_j$都有路径，即顶点$v_i$和$v_j$是连通的，则称该图为连通图。

#### 连通分量（Connected Component）
连通分量是指无向图中的极大连通子图。连通图的连通分量就是其自己，非连通图会有多个连通分量。

#### 强连通图（Strongly Connected Graph）
对于有向图，如果任意两个顶点$v_i$和$v_j$都满足$v_i$到$v_j$有路径，同时顶点$v_j$到$v_i$也有路径，则称该有向图为强连通图。

#### 强连通分量（Strongly Connected Components）
有向图的极大强连通子图称为强连通分量。强连通图的强连通分量就是其自己，非强连通图会有多个强连通分量。

#### 生成树、生成森林
一个连通图的极小连通子图称为生成树（Span Tree）。生成树是一个包含图的$n$个顶点和$n-1$条边的连通子图，这里$n$为图的顶点数。

如果是非连通图，则每个连通分量可以得到一棵连通分量的生成树，合在一起就是该非连通图的生成森林。

### 6.2.2 图的操作定义

图是一种数据元素之间具有多对多关系的复杂数据结构，通常图的基本操作需要包含图的创建与销毁、图中顶点的增加与删除、关系的增加与删除、查找与读写顶点数据、图的遍历算法等。下面将图的数据结构和基本操作组合在一起，给出图这个抽象数据类型的完整描述。

```markdown
ADT Graph {
    数据对象:$V = \{v_i \mid v_i \in ElemSet, \ i \geqslant 1\}$
    数据关系:$VR = \{\langle v_i, v_j \rangle \mid v_i, \ v_j \in ElemSet, \ \langle v_i, v_j \rangle \text{ 表示 } v_i \text{ 到 } v_j \text{ 的弧，} P(v_i, v_j) \text{ 为弧上的信息}\}$

    基本操作:
        GraphCreate(&G, V, VR)          // 由$V$和$VR$创建图$G$
        GraphDestroy(&G)                 // 销毁图$G$
        LocateVex(G, u)                  // 根据$u$查找顶点
        PutVex(&G, u, value)             // 将值$value$赋予$u$表示的顶点
        FirstAdjVex(G, u)                // 求顶点$u$的第一个邻接顶点
        NextAdjVex(G, u, w)              // 求顶点$u$相对于$w$的下一个邻接顶点
        InsertVex(&G, v)                 // 插入顶点$v$
        DeleteVex(&G, u)                 // 删除顶点$u$
        InsertArc(&G, u, w)              // 插入顶点$u$到顶点$w$的弧
        DeleteArc(&G, u, w)              // 删除顶点$u$到顶点$w$的弧
        DFSTraverse(G, visit())          // 深度优先遍历
        BFSTraverse(G, visit())          // 广度优先遍历
}
End ADT
```

上述基本操作中的参数部分，$u$和$w$或者与图中顶点具有相同特征，或者是顶点的关键属性（也称为关键字），依据$u$和$w$能区分不同的顶点；$v$与图中顶点具有完全相同特征；`visit` 是一个对顶点访问的函数，用户可根据实际要求自行定义，例如显示顶点的值。

## 6.3 图的存储结构

### 6.3.1 邻接矩阵

首先介绍的是数组表示法，即用两个数组分别存储顶点的信息和顶点之间的关系。这是一种顺序存储与顺序存储组合在一起而形成的存储结构。

用来存放图中$n$个顶点的数组称为顶点数组。我们可将图中顶点按任意顺序保存到顶点数组中，这样按存放次序每个顶点就对应一个位置序号（简称位序），依次为$0 \sim n-1$；接着用一个$n \times n$的二维数组（称为邻接矩阵）来表示顶点间的关系，用$1$表示顶点间有关系、$0$表示没有关系，如果顶点序号为$i$的顶点（用$v_i$表示）和顶点序号为$j$的顶点（用$v_j$表示）$(0 \leq i, j \leq n-1, i \neq j)$有关系，则邻接矩阵的第$i$行第$j$列为$1$，否则为$0$。显然，无向图的邻接矩阵是一个对称矩阵，而有向图的邻接矩阵不一定对称。习惯上，称数组表示法为邻接矩阵表示法（简称邻接矩阵）。图 6.6 所示为有向图$G_1$和无向图$G_2$的邻接矩阵。

根据无向图的邻接矩阵$A$，计算第$i$行或第$i$列上的数字之和能非常容易地求得顶点$v_i$的度。即：
$$
TD(v_i) = \sum_{j=0}^{n-1} A[i][j] = \sum_{j=0}^{n-1} A[j][i] \quad 0 \leq i \leq n-1
$$

如果是有向图，需要根据第$i$行求顶点$v_i$的出度、第$i$列求顶点$v_i$的入度，再相加得到顶点$v_i$的度。即：
$$
TD(v_i) = OD(v_i) + ID(v_i) = \sum_{j=0}^{n-1} A[i][j] + \sum_{j=0}^{n-1} A[j][i] \quad 0 \leq i \leq n-1
$$

对于有向网（或无向网），根据邻接矩阵求顶点$v_i$的度时，可通过统计第$i$行以及（或者）第$i$列上非无穷大权值的个数，求有向网顶点$v_i$的出度和入度（或无向网顶点$v_i$的度）。

明确数组表示法的数据存放方式后，接下来的任务就是将两个数组与相关的属性整合在一片连续的内存空间中，用 C 语言定义它的数据类型。

```cpp
#define MAX_VERTEX 30
typedef enum {DG, DN, UDG, UDN} GraphKind;
// DG、DN、UDG 和 UDN 分别表示有向图、有向网、无向图和无向网
typedef struct {
    VertexType vexs[MAX_VERTEX]; // VertexType 为顶点类型，类似 ElemType
    int arcs[MAX_VERTEX][MAX_VERTEX];
    int vexnum, arcnum;
    GraphKind kind;
} MGraph;
```

#### 例 6-1：以邻接矩阵为存储结构，实现基本操作——创建有向图。

在创建图时，首先将顶点数据全部保存到顶点数组中；对每一对顶点表示的关系$\langle v_i, v_j \rangle$查找两个顶点的序号$i$和$j$，对邻接矩阵的第$i$行第$j$列赋值$1$并对相关属性赋值，以完成创建操作。算法代码如下。

```cpp
status GraphCreate(MGraph &G, VertexType V[], VertexType VR[][2], int vexnum, int arcnum)
{
    G.vexnum = vexnum; G.arcnum = arcnum; G.kind = DG;
    int i, j;
    for (i = 0; i < G.vexnum; i++) G.vexs[i] = V[i]; // 初始化各顶点
    memset(&G.arcs[0][0], 0, sizeof(G.arcs));
    for (int k = 0; k < G.arcnum; k++) {
        for (i = 0; i < G.vexnum; i++) {
            if (G.vexs[i] == VR[k][0]) break;
        }
        for (j = 0; j < G.vexnum; j++) {
            if (G.vexs[j] == VR[k][1]) break;
        }
        if (i >= G.vexnum || j >= G.vexnum) return ERROR;
        G.arcs[i][j] = 1;
    }
    return OK;
}
```

### 6.3.2 邻接表

图的第二种存储结构是邻接表。这是一种顺序存储与链式存储组合而成的存储结构，其通过头结点数组保存所有的顶点信息，用单链表保存顶点之间的关系。

对于一个无向图$G$，首先需要一个头结点数组来保存所有顶点，这样每个顶点都对应一个$0 \sim n-1$范围内的位置序号，这里$n$表示顶点数。头结点数组中的每个元素（头结点）包含两个部分：一个是顶点的值；另一个是单链表的头指针，该头指针指向一个由所有邻接顶点的序号构成的单链表，每个单链表的表结点代表一条依附于该顶点的边。例如，如果顶点序号为$i$的顶点$v_i$和顶点序号为$j$的顶点$v_j$$(0 \leq i, j \leq n-1, i \neq j)$有关系，则$v_i$的头结点对应的第$i$个单链表中就会有一个表结点，表结点的值为$j$，表示$v_i$和$v_j$之间有一条边；同时$v_j$对应的第$j$个单链表中也会有一个表结点，表结点的值为$i$。这样在一个无向图中，如果有$e$条边，对应就有$2e$个单链表结点。显然，顶点$v_i$的度等于第$i$个单链表长度。

对于一个有向图$G$，如果顶点$v_i$到顶点$v_j$有一条弧，则第$i$个单链表中就会有一个表结点，表结点的值为$j$，也就是以这条弧的弧头顶点序号作为表结点的值，所以一条弧对应一个表结点。

在有向图的邻接表中，要计算顶点$v_i$的出度，我们只需求第$i$个单链表的表长；但求入度时，就需要遍历所有的单链表，统计结点值为$i$的表结点数量。

根据上面的描述，我们可以给出邻接表中的表结点、头结点数组数据类型的定义，并进一步组合出邻接表的类型定义。

```cpp
#define MAX_VERTEX 30
typedef struct ArcNode {
    int adjvex;          // 顶点位置序号
    struct ArcNode *nextarc; // 下一个表结点指针
    int weight;          // 无向网和有向网需要的边或弧权值
} ArcNode;
typedef struct VertexNode {
    VertexType data;     // 顶点信息
    ArcNode *firstarc;   // 指向第一条弧或邻接顶点
} VertexNode, AdjList[MAX_VERTEX];
typedef struct {
    AdjList vertices;    // 头结点数组
    int vexnum, arcnum;  // 顶点数、弧数
    GraphKind kind;      // 图的类型
} ALGraph;
```

#### 例 6-2：以邻接表为存储结构，实现基本操作——创建无向图。

在创建图时，首先将顶点数据全部保存到头结点数组中，将对应每个单链表头指针设置为空；对每一对关系$\langle v_i, v_j \rangle$查找两个顶点的序号$i$和$j$，对第$i$个单链表以首插法（也可尾插法）插入结点值为$j$的表结点，同时对第$j$个单链表以首插法（也可尾插法）插入结点值为$i$的表结点，并对相关属性赋值，以完成创建操作。算法代码如下。

```cpp
status GraphCreate(ALGraph &G, VertexType V[], VertexType VR[][2], int vexnum, int arcnum) {
    G.vexnum = vexnum; G.arcnum = arcnum; G.kind = UDG;
    int i, j, k;
    for (i = 0; i < G.vexnum; i++) {
        G.vertices[i].data = V[i];
        G.vertices[i].firstarc = NULL;
    }
    for (k = 0; k < G.arcnum; k++) {
        for (i = 0; i < G.vexnum; i++) {
            if (G.vertices[i].data == VR[k][0]) break;
        }
        for (j = 0; j < G.vexnum; j++) {
            if (G.vertices[j].data == VR[k][1]) break;
        }
        if (i >= G.vexnum || j >= G.vexnum) return ERROR;
        ArcNode *p = (ArcNode *) malloc(sizeof(ArcNode));
        p->adjvex = j;
        p->nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p;
        p = (ArcNode *) malloc(sizeof(ArcNode));
        p->adjvex = i;
        p->nextarc = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p;
    }
    return OK;
}
```

### 6.3.3 十字链表

图的第三种存储结构是十字链表，这是针对有向图设计的一种存储结构。我们可以将其看成是邻接表与逆邻接表的一种结合。

十字链表中，用一个弧结点表示一条弧。如果$v_i$到$v_j$有弧，则在弧结点中包括弧尾$v_i$和弧头$v_j$这两个顶点的位置序号$i$和$j$，同时对应也包含两个链表指针：一个指向下一条以$v_i$作为弧尾的弧结点；另一个指向下一条以$v_j$作为弧头的弧结点。

可以看到，以十字链表作为存储结构时，弧的增减需要在两个单链表中同时进行弧结点的增、删操作。在十字链表中求一个顶点的度时，根据该顶点的 `firstin` 这条链统计弧结点个数得到入度，根据 `firstout` 这条链统计弧结点个数得到出度，不需要像邻接表一样遍历全部的表结点。

### 6.3.4 邻接多重表

在无向图的邻接表中，一条边对应两个表结点导致有些操作不太方便。为此，针对无向图设计了图的第四种存储结构：邻接多重表。在邻接多重表中，一条边只需要一个表结点保存。

类似于十字链表，如果某条边关联到顶点$v_i \sim v_j$，则对应表结点中包括这两个顶点的序号$i$和$j$，同时相应地也包含两个链表指针：一个指向下一条关联到顶点$v_i$的边的表结点，另一个指向下一条关联到顶点$v_j$的边的表结点。为了方便搜索，为表结点可以增加一个标志域 `mark`。
## 6.4 图的遍历

### 6.4.1 图的深度优先遍历

深度优先遍历的思想类似于树的先根遍历算法。假定从图中的某个顶点$v_1$出发，首先访问出发点$v_1$，然后选择一个未被访问过的邻接点$v_2$，以$v_2$作为新的出发点继续深度优先搜索，直到所有与$v_1$相连通的顶点（或有向图中由$v_1$出发可以到达的顶点）被访问。如果图中还有未被访问的顶点，再选择一个顶点作为起点进行深度优先搜索，直至所有图的顶点被访问。

```cpppp
void DFS(ALGraph G, int v, bool visited[], status (*visit)(ALGraph, int)) {
    visited[v] = true;          // 标注访问过的标记
    visit(G, v);                // 使用 visit 函数访问序号为$v$的顶点
    for (int w = FirstAdjVex(G, v); w >= 0; w = NextAdjVex(G, v, w)) {
        if (!visited[w])         // 处理所有未访问的邻接顶点
            DFS(G, w, visited, visit);
    }
}

void DFSTraverse(ALGraph G, status (*visit)(ALGraph, int)) {
    bool visited[G.vexnum];
    for (int v = 0; v < G.vexnum; v++) // 初始化各顶点未访问状态
        visited[v] = false;
    for (int v = 0; v < G.vexnum; v++) // 从一个未访问的顶点开始
        if (!visited[v])
            DFS(G, v, visited, visit);
}
```

算法的时间效率与存储结构有关。如果采用邻接矩阵表示法，由于访问每个顶点后都要检查它的邻接顶点是否已被访问，这时需要查找邻接矩阵一行（或一列）的$n$个值，因此需要的时间为$O(n^2)$，即$T(n) = O(n^2)$；用邻接表表示法时，访问每个顶点后都要遍历该顶点的表结点链表，检查邻接顶点的访问状态，$n$个顶点的表结点链表都会被遍历一次，共计访问了$e$个表结点，所以$T(n) = O(n + e)$。

---

### 6.4.2 图的广度优先遍历

广度优先遍历的思想类似于树的按层遍历算法。假定从图中的某个顶点$v$出发，首先访问出发顶点$v$，然后依次访问$v$的所有未被访问过的邻接点，并记住这个访问次序；在后续访问过程中，使得“先被访问过的顶点的邻接顶点”先于“后被访问过的顶点的邻接顶点”被访问，直到所有与$v$相连通的顶点被访问。

如果图中还有未被访问的顶点，再选择一个顶点作为起点进行广度优先搜索，直至所有图的顶点被访问。广度优先遍历的过程就是以某顶点$v$为起点，由近至远地依次访问与$v$相通的顶点（或有向图中由$v$出发可以到达的顶点）。

```cpppp
void BFSTraverse(ALGraph G, status (*visit)(ALGraph, int)) {
    bool visited[MAX_VERTEX];
    for (int v = 0; v < G.vexnum; v++) // 初始化各顶点未访问状态
        visited[v] = false;
    LinkQueue Q; InitQueue(Q);         // 队列$Q$初始化
    for (int v = 0; v < G.vexnum; v++) // 按顶点位置序号依次选择顶点
        if (!visited[v]) {              // 遇到未访问过的顶点开始遍历
            visited[v] = true; visit(G, v);
            EnQueue(Q, v);
            int u;
            while (!QueueEmpty(Q)) {
                DeQueue(Q, u);
                for (int w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w))
                    if (!visited[w]) {
                        visited[w] = true;
                        visit(G, w);
                        EnQueue(Q, w);
                    }
            }
        }
}
```

该算法的时间效率与深度优先遍历算法相同。

---

## 6.5 图的生成树问题

### 6.5.1 生成树与最小生成树

### 6.5.2 最小生成树 Prim 算法

Prim 算法思想：给定一个无向连通网$G = (V, E)$，求最小生成树$T = (U, TE)$。初始化时，从某个顶点$u_0$开始，即顶点集合$U$只包含一个顶点$u_0$，边的集合$TE$为空集。在所有一端属于顶点集合$U$，另外一端属于顶点集合$V - U$的边的集合中，找一条最小权值的边$(u, v)$，这里$u \in U$，$v \in V - U$，将顶点$v$加到集合$U$中，将边$(u, v)$加到$TE$中，这样重复$n - 1$次，$U$中有了$n$个顶点，$TE$中有了$n - 1$条边，即可得到一个最小生成树。由于可能存在多条具有最小权值的边，选择边的次序不同，会得到不同形态的最小生成树。

下面以邻接矩阵作为存储结构，依据 Prim 算法思想求解最小生成树时，需要一个大小为$n - 1$的结构数组$T$来记录生成树的$n - 1$条边：$(T[i].v1, T[i].v2)$，权值为$T[i].lowcost$，这里$0 \leq i \leq n - 2$，$0 \leq v1, v2 \leq n - 1$。在求解过程中，当$T[i]$表示的边不属于$TE$时，$T[i].lowcost$记录顶点集合$V - U$中的某个顶点$T[i].v2$到$U$中顶点的边的最小权值，以及在$U$中依附的顶点$T[i].v1$（请读者注意$T[i]$的含义）。也就是说，$V - U$中的某个顶点可能会与$U$中的多个顶点相邻，只需记录最小权值，以及这个最小权值的边在$U$中依附的顶点$T[i].v1$。

假定从$G$的一个序号为$k$的顶点$u$开始求$G$的最小生成树，初始化时序号为$k$的顶点$u$在集合$U$中，$V - U$中有$n - 1$个顶点，在$T$中生成$n - 1$条边，边$T[i].v1$的值为$k$，$T[i].v2$的值分别是$V - U$中各顶点序号$j$，$T[i].lowcost$为序号$k$顶点与序号$j$顶点边的权值，其中$0 \leq i \leq n - 2$，$0 \leq j \leq n - 1$，$j \neq k$。

为了标识$T$的$n - 1$条边的性质，我们可以增加一个大小为$n - 1$的标识数组，以标识每条边是否在$TE$中，也可以当边$T[i]$属于$TE$时，将$T[i].lowcost$翻转成相反数，表示该边的两端顶点都在$U$中。下面算法实现时采用后一种方式，即当$T[i].lowcost > 0$时，这里$0 \leq i \leq n - 2$，表示$T[i]$这条边一端在$U$、另一端在$V - U$中，$T[i]$不属于$TE$。

在$T$中求一端在$U$、另一端在$V - U$中的边的权值最小值，其下标为$min$。求得$min$后，通过将$T[min].lowcost$翻转成相反数，表示将顶点$T[min].v2$加入$U$中，以及一条边$(T[min].v1, T[min].v2)$加入$TE$，再根据顶点$T[min].v2$更新$V - U$中其他顶点与$U$中顶点的边，一旦有更新，就将该边的属性$v1$更新为$T[min].v2$。通过该步骤实现将$V - U$中的一个顶点加入$U$中，同时增加一条边到$TE$中，重复$n - 1$次，完成最小生成树的求解。

**例 6-5**: 最小生成树 Prim 算法如下。

```cpppp
typedef struct MSpanTreeEdge {
    int v1, v2;                  // v1、v2 分别是$U$和$V - U$中顶点在图$G$中序号
    int lowcost;
} *MSpanTree;

MSpanTree Prim(MGraph G, VertexType u) {
    MSpanTree T;
    T = (MSpanTree)malloc((G.vexnum - 1) * sizeof(struct MSpanTreeEdge));
    int i, j, k;
    k = LocateVex(G, u);          // 确定起始顶点$u$的位置序号
    for (i = j = 0; i < G.vexnum; i++) // 初始化$V - U$中顶点到$u$的最小权值
        if (i != k) {
            T[j].v1 = k;
            T[j].v2 = i;
            T[j++].lowcost = G.arcs[k][i];
        }
    for (i = 1; i < G.vexnum; i++) {      // 依次选择$n - 1$条边
        int mincost = INFINITY, min;      // 置 mincost 初值为无穷大
        for (j = 0; j < G.vexnum - 1; j++) // 找一端在$U$、另一端在$V - U$的最小边
            if (T[j].lowcost > 0 && T[j].lowcost < mincost)
                min = j, mincost = T[j].lowcost;
        T[min].lowcost *= -1;              // 将$T[min]$表示的边加入$TE$中
        k = T[min].v2;                     // 序号$k$的顶点要加入$U$中
        for (j = 0; j < G.vexnum - 1; j++) // 更新$V - U$中顶点到序号$k$顶点的边权值
            if (T[j].lowcost > 0 && T[j].lowcost > G.arcs[k][T[j].v2]) {
                T[j].v1 = k;
            }
    }
    return T;                              // 返回前可把各边权值由负改变成正
}
```

算法每次选择出一个顶点和一条边后，需要在邻接矩阵中，根据该顶点对应这一行的$n$个权值进行更新操作，共需要选择$n - 1$个顶点，所以算法的时间复杂度为$O(n^2)$。

Prim 算法适用于对稠密图的连通网求最小生成树的情况。

---

### 6.5.3 最小生成树 Kruskal 算法

下面要讨论的是克鲁斯卡尔（Kruskal）算法。该算法适用于对稀疏图的连通网求最小生成树的情况。

假定一个无向连通网为$G = (V, E)$，其最小生成树为$T = (V, TE)$。初始化时，$T$的顶点集合包含$G$中的全部顶点，$TE$为空集，这时$T$中各个顶点自成一个连通分量。在无向连通网$G$中按权值从小到大选择边$(u, v)$，如果$u$、$v$在不同的连通分量中，则该边加到生成树$T$中不会形成回路，成功将边$(u, v)$加到$TE$中，$u$和$v$所属的连通分量合并成一个，否则舍弃该边。依此操作，直到成功地加上$n - 1$条边到$TE$中为止。或者说，当$T$中的所有顶点连接成一个连通分量时，就求解到了一棵最小生成树。

克鲁斯卡尔算法适合求解边稀疏的连通网最小生成树，所以我们可以考虑对其数据采用邻接表的存储结构。根据上述算法思想，使用一个结构数组 `edges` 保存所有边的两顶点序号与权值，并按权值进行排序；每一个连通分量对应一个顶点的集合，当选择的最短边$(v_i, v_j)$依附的顶点$v_i$和$v_j$在不同的连通分量中时，将该边加入生成树$T$中。这个过程要用到查找顶点$v_i$和$v_j$所在的连通分量以及使用边$(v_i, v_j)$将$v_i$和$v_j$所在的连通分量合并成一个连通分量，即对应查找顶点$v_i$和$v_j$所在的连通分量顶点集合以及将两个顶点集合合并的操作。这个操作很自然地用到了并查集这种树状的数据结构，完成集合元素的查找、集合的合并以及查找路径的压缩。有关并查集的算法会在 6.8.1 小节详细介绍。

采用树的双亲表示法在数组$V$中记录各顶点连通分量集合，每个连通分量的顶点集合组成一棵树，$V$中每个顶点对应一个树结点，通过判断两个结点所在树的根结点是否相同来确定它们是否在同一个连通分量中。初始化设置$V[i] = i$（这里$0 \leq i \leq n - 1$），表示结点$v_i$的父结点是自身，即为树的根结点，这样形成了$n$棵树的森林，对应$n$个连通分量。在后续操作中，每当选择一条边$(v_i, v_j)$时，调用查找函数 `findSet`，根据$i$查找结点$v_i$所在树的根结点：假定根结点序号为$k$，$v_i$的祖先结点序号依次为$k, k_1 \cdots k_\circ$。查找函数 `findSet` 返回$k$，同时在查找过程中修改查找路径上所有祖先结点的父结点序号，将$V[k_i] \cdots V[k_\circ]$和$V[i]$都更新成$k$，即可实现查找路径的压缩，提高后续查找的效率。如果$v_i$和$v_j$所在树的根结点相同，表示边依附的两顶点在同一个连通分量中，舍弃该边，否则该边作为最小生成树的边并输出，同时将$v_j$的根结点设置为$v_i$根结点的父结点，实现两个集合的合并，合并两个连通分量。

**例 6-6**: 最小生成树 Kruskal 算法如下。

```cpppp
int findSet(int V[], int i) {
    // 并查集查找序号$i$的顶点所在连通分量树的根顶点序号，同时压缩查找路径
    return V[i] == i ? i : V[i] = findSet(V, V[i]);
}

typedef struct edge { int i, j, w; } edge;     // edge 表示边和权值
bool cmp(edge e1, edge e2) { return e1.w < e2.w; }
status kruskal(ALGraph G) {
    edge edges[G.arcnum];                      // edges 存放全部边和权值
    int V[G.vexnum], nums = 0;                 // V 采用树的双亲表示法记录各连通分量
    int i, j, k;
    for (i = 0, k = 0; i < G.vexnum; i++) // 访问邻接表每个结点获取每条边的信息
        for (ArcNode *p = G.vertices[i].firstarc; p; p = p->nextarc) {
            j = p->adjvex;
            if (i < j) edges[k].i = i, edges[k].j = j, edges[k++].w = p->weight;
        }
    sort(edges, edges + G.arcnum, cmp);        // 将边按边权值递增排序
    for (k = 0; k < G.arcnum; k++) {
        i = findSet(V, edges[k].i);
        j = findSet(V, edges[k].j);
        if (i != j) {                          // 边 edges[k] 依附的两顶点不在同一个连通分量中
            V[i] = j;                          // 合并两个连通分量
            printf("%c->%c, 权值: %d\n", G.vertices[edges[k].i].data,
                   G.vertices[edges[k].j].data, edges[k].w); // 输出边 edges[k]
            if (++nums == G.vexnum - 1) break;
        }
    }
    return OK;
}
```

算法在时间开销$O(n + e)$内将网中的所有边访问到，因为$n < e$，所以时间开销可表示为$O(e)$，再使用排序快速算法将其处理成有序序列，时间开销为$O(e \log e)$。最后算法的时间复杂度为$O(e \log e)$。

---

## 6.6 图的最短路径问题

### 6.6.1 单源最短路径 Dijkstra 算法

**例 6-7**: 单源最短路径 Dijkstra 算法如下。

```cpppp
void ShortPath_Dijkstra(MGraph G, int s, int P[], int D[]) {
    // 求$v_s$到其他顶点的最短路径
    int final[G.vexnum];
    for (int i = 0; i < G.vexnum; i++) { // 初始化，源点序号为$s$
        final[i] = false;
        P[i] = s;                       // 前驱顶点序号
        D[i] = G.arcs[s][i];            // 初始距离
    }
    D[s] = 0; final[s] = true;
    for (int i = 1; i < G.vexnum; i++) { // 求$v_s$到其他$n - 1$个顶点的最短路径
        int j, min = INFINITY;          // 查找满足 final[j] 为 FALSE 且 D[j] 具有最小值的情况
        for (int i = 0; i < G.vexnum; i++)
            if (!final[i] && D[i] != INFINITY && D[i] < min) {
                min = D[i];
                j = i;
            }
        final[j] = true;                // 标识序号$j$的顶点最短路径已确定
        for (int k = 0; k < G.vexnum; k++) {
            if (!final[k] && k != j && D[k] > D[j] + G.arcs[j][k]) {
                D[k] = D[j] + G.arcs[j][k]; // 修改路径长度
                P[k] = j;                   // 修改前驱顶点编号
            }
        }
    }
}
```

**例 6-8**: 最短路径显示算法如下。

```cpppp
void DisplayShortPath0(MGraph G, int s, int P[], int i) {
    // 按假定顶点类型是一个字符串来进行的输出
    if (i == s)
        printf("%c", G.vexs[s]);         // 显示源点
    else {
        DisplayShortPath0(G, s, P, P[i]);
        printf(" %c", G.vexs[i]);
    }
}

void DisplayShortPath(MGraph G, int s, int P[], int D[]) {
    for (int i = 0, k = 1; i < G.vexnum; i++) // 输出$n - 1$条路径
        if (i != s && D[i] != INFINITY) {
            printf("第%d条最短路径长度:%d, 路径顶点序列: ", k++, D[i]);
            DisplayShortPath0(G, s, P, i); // 显示源点$v_s$到$v_i$的最短路径
            printf("\n");
        }
}
```

---

### 6.6.2 各顶点间最短路径 Floyd 算法

弗洛伊德算法思想是：根据有向网$G$的邻接矩阵（也称为代价矩阵），复制构造出一个$n \times n$的矩阵$D^{(1)}$，如果由$v_i$到$v_j$有弧，则$v_i$到$v_j$有一条长度为$D^{(1)}[i][j]$的路径$(v_i, v_j)$，但它不一定是$v_i$到$v_j$的最短路径，还需要进行$n$次测试。首先考虑路径$(v_i, v_0, v_j)$是否存在，如果存在就将其与$(v_i, v_j)$比较路径长度，取较小者来代替$(v_i, v_j)$的路径长度，并赋予$D^{(0)}[i][j]$；对$G$的每一对顶点都做这样以$v_0$作为中间顶点的试探后得到矩阵$D^{(1)}$，则$D^{(1)}[i][j]$表示从$v_i$到$v_j$的中间顶点序号不大于$0$的最短路径长度。

接着对矩阵$D^{(0)}$再用$v_1$来试探，考虑路径$(v_i, \cdots, v_1, \cdots, v_j)$，此时$(v_i, \cdots, v_1)$和$(v_1, \cdots, v_j)$都是中间顶点序号不超过$0$的最短路径，对应最短路径长度为$D^{(0)}[i][1]$和$D^{(0)}[1][j]$，取$D^{(0)}[i][1] + D^{(0)}[1][j]$与$D^{(0)}[i][j]$的较小值，将其值赋予$D^{(1)}[i][j]$，则$D^{(1)}[i][j]$表示从$v_i$到$v_j$的中间顶点序号不大于$1$的最短路径长度；同样对$G$的每一对顶点都做以$v_k$作为中间顶点的试探后得到矩阵$D^{(k)}$。最后一次对矩阵$D^{(n-1)}$用$v_{n-1}$来试探后得到矩阵$D^{(n-1)}[i][j]$就是从$v_i$到$v_j$的中间顶点序号不大于$n - 1$的最短路径长度，即为最终结果。这个由$G$的邻接矩阵到矩阵$D^{(n-1)}$的过程可表示为：

$$
D^{(-1)}[i][j] = G.arcs[i][j]
$$

$$
D^{(k)}[i][j] = \min \{ D^{(k-1)}[i][j], D^{(k-1)}[i][k] + D^{(k-1)}[k][j] \} \quad 0 \leq k \leq n - 1
$$

记录最短路径上的顶点序列，类似求单源最短路径算法，定义一个$n \times n$的二维数组$P$，在由矩阵$D^{(k-1)}$用$v_k$作为中间结点的试探过程中，一旦要将$D^{(k-1)}[i][k] + D^{(k-1)}[k][j]$赋予$D^{(k)}[i][j]$时，就将$P[i][j]$更新为$k$，表示当前最短路径上包含中间顶点$v_k$，最后对$P$进行分析，求出所有的最短路径。

**例 6-9**: 各顶点间最短路径 Floyd 算法如下。

```cpppp
void ShortPath_Floyd(MGraph G) {
    int P[G.vexnum][G.vexnum], D[G.vexnum][G.vexnum];
    for (int i = 0; i < G.vexnum; i++) // 初始化
        for (int j = 0; j < G.vexnum; j++) {
            P[i][j] = -1;               // -1 表示无中间顶点
            D[i][j] = G.arcs[i][j];
        }
    for (int k = 0; k < G.vexnum; k++) { // 依次选定中间顶点$v_0, v_1, \cdots, v_{n-1}$
        for (int i = 0; i < G.vexnum; i++) // 处理任意两顶点$v_i$与$v_j$间最短路径
            for (int j = 0; j < G.vexnum; j++)
                if (i != j && D[i][j] > D[i][k] + D[k][j]) {
                    D[i][j] = D[i][k] + D[k][j]; // 取较短路径
                    P[i][j] = k;                 //$v_i$到$v_j$的中间顶点$v_k$
                }
    }
}
```

---

## 6.7 有向无环图的应用

### 6.7.1 拓扑排序

**例 6-10**: 拓扑排序算法如下。

```cpppp
int TopSort(ALGraph G) {
    // 成功完成拓扑排序后，返回 OK，否则有回路，返回 ERROR
    int *indegree, *ve, *vl, *vi, *vj;
    ArcNode *p;
    struct { int data[MAX_VERTEX], top; } S1, S2;
    S1.top = S2.top = 0;
    indegree = (int *)calloc(G.vexnum, sizeof(int));
    ve = (int *)calloc(G.vexnum, sizeof(int));
    for (i = 0; i < G.vexnum; i++) // 统计顶点入度
        for (ArcNode *p = G.vertices[i].firstarc; p; p = p->nextarc)
            indegree[p->adjvex]++;
    for (int i = 0; i < G.vexnum; i++) // 入度为 0 的顶点序号进栈
        if (!indegree[i]) S.data[S.top++] = i;
    while (S.top) {
        int i = S.data[--S.top];
        nums++;
        printf("%c ", G.vertices[i].data);
        for (ArcNode *p = G.vertices[i].firstarc; p; p = p->nextarc) {
            int j = p->adjvex;
            if (!--indegree[j]) S.data[S.top++] = j; // 入度减 1 后为 0，进栈
        }
    }
    if (nums < G.vexnum) return ERROR; // 有回路
    else return OK;
}
```

对于一个有$n$个顶点、$e$条边的有向图而言，分析各个顶点入度的算法时间效率为$O(n + e)$，使用栈保存入度为 0 的顶点，每个顶点都需要入栈、出栈 1 次，每条弧都需要完成入度减 1 操作一次，这样最后综合算法时间复杂度为$O(n + e)$。

---

### 6.7.2 关键路径

**例 6-11**: 基于邻接表的关键路径算法如下。

```cpppp
status CriticalPath(ALGraph G) {
    int *indegree, *ve, *vl, *vi, *vj;
    ArcNode *p;
    struct { int data[MAX_VERTEX], top; } S1, S2;
    S1.top = S2.top = 0;
    indegree = (int *)calloc(G.vexnum, sizeof(int));
    ve = (int *)calloc(G.vexnum, sizeof(int));
    for (i = 0; i < G.vexnum; i++) // 统计顶点入度
        for (ArcNode *p = G.vertices[i].firstarc; p; p = p->nextarc)
            indegree[p->adjvex]++;
    for (int i = 0; i < G.vexnum; i++) // 入度为 0 的顶点序号进栈
        if (!indegree[i]) S1.data[S1.top++] = i;
    while (S1.top) {
        int i = S1.data[--S1.top];
        nums++;
        S2.data[S2.top++] = i; // 数组访问过的顶点
        for (p = G.vertices[i].firstarc; p; p = p->nextarc) {
            j = p->adjvex;
            if (!--indegree[j]) S1.data[S1.top++] = j; // 入度减 1 后为 0，进栈
            if (ve[i] + p->weight > ve[j]) // 用较大值替换
                ve[j] = ve[i] + p->weight;
        }
    }
    if (nums < G.vexnum) return ERROR; // 有回路，工程无法进行
    for (i = 0; i < G.vexnum; i++) vl[i] = ve[G.vexnum - 1]; // 初始化顶点事件最迟发生时间
    while (S2.top) {
        for (i = S2.data[--S2.top], p = G.vertices[i].firstarc; p; p = p->nextarc) {
            j = p->adjvex;
            if (vl[j] - p->weight < vl[i]) // 用较小值替换
                vl[i] = vl[j] - p->weight;
        }
    }
    for (i = 0; i < G.vexnum; i++) // 按顶点次序，取出该顶点作为弧尾的各条弧分析
        for (p = G.vertices[i].firstarc; p; p = p->nextarc) {
            j = p->adjvex;
            int ee = ve[i];
            int el = vl[j] - p->weight; // 最早、最迟开始时间
            if (ee == el) // 输出关键活动
                printf("%c->%c 权值: %d\n", G.vertices[i].data, G.vertices[j].data, p->weight);
        }
    return OK;
}
```

关键路径算法实现时，进行一次拓扑排序和一次逆拓扑排序，时间复杂度为$O(n + e)$；最后计算活动的最早和最迟开始时间时，也是对邻接表的全部顶点和全部弧遍历一次，时间复杂度为$O(n + e)$。综合得到关键路径算法的时间复杂度为$O(n + e)$。

以下是将图片中的内容转换为 Markdown 格式，并使用 `$$` 包裹公式的内容：

---

# 第 7 章 排序

## 7.1 实际应用中的排序

排序是以某一数据项（称为排序关键字）为依据，将一组无序记录调整成一组有序记录的过程。排序问题可以定义为以下形式：

- **输入**：一个长度为$n$的记录序列$(r_1, r_2, \cdots, r_n)$，其相应排序关键字为$(k_1, k_2, \cdots, k_n)$。
- **输出**：输入记录序列的重新组合$(r'_1, r'_2, \cdots, r'_n)$，相应排序关键字满足$k'_1 \leqslant k'_2 \leqslant \cdots \leqslant k'_n$。

这里使用抽象数据类型表示待排序文件及文件中的记录，并默认排序关键字为整数类型，排序方式为以排序关键字由小到大的顺序进行排列。使用 C/C++ 语言定义待排序文件及文件中的记录如下：

```cpp
#define MAXSIZE 20      // 文件最大长度
typedef int KeyType;    // 排序关键字类型
typedef int InfoType;   // 其他数据项类型

// 记录定义
struct record {
    KeyType key;
    InfoType otherinfo;
};

// 待排序文件定义
typedef struct {
    record r[MAXSIZE + 1];  // r[0] 用作监视哨
    int length;             // 实际表长
} SqList;
```

## 7.2 排序的概述

### 7.2.1 排序算法的稳定性

如果排序算法在任意待排序文件下都能够确保“算法运行前后，具有相同排序关键字记录的相对位置不发生改变”，那么此排序算法是稳定的排序算法；否则，此排序算法是不稳定的。

### 7.2.2 排序算法的分类

排序算法可根据排序过程中所使用存储器类型划分为内部排序算法和外部排序算法。

- **内部排序算法**：排序过程中只使用内存存储数据、调整数据位置的排序算法。内部排序算法可根据排序算法设计思想划分为插入排序算法、交换排序算法、选择排序算法、归并排序算法、分配排序算法。
- **外部排序算法**：排序过程中需要借助外存存储数据或调整数据位置的排序算法。

### 7.2.3 排序算法的性能优劣

排序算法性能的优劣主要取决于时间复杂度和空间复杂度。

#### 1. 时间复杂度

时间复杂度是通过分析排序算法执行过程中的关键字比较次数和移动次数得出的。

由于待排序文件中记录的初始顺序对排序过程中的关键字比较次数和移动次数具有直接影响，因此，我们通常需要计算排序算法在最好情况、最坏情况、平均情况这 3 种情况下的关键字比较次数和移动次数，以获得算法在这 3 种情况下的时间复杂度。

#### 2. 空间复杂度

空间复杂度是指排序过程中所开辟的辅助存储空间大小（不包含待排序文件所使用空间）。

## 7.3 插入排序算法

插入排序算法是最为简单的一种排序算法。对于少量元素的排序来说，它是一个有效的算法。常用的插入排序算法有直接插入排序算法、折半插入排序算法和希尔排序算法等。

### 7.3.1 直接插入排序算法

直接插入排序（也叫线性插入排序）算法是最简单的插入排序算法，其设计思想为：将待排序文件划分为空子文件和无序子文件，依次选取无序子文件中的记录，将其插入有序子文件的相应位置（有序子文件在插入新记录后依然有序），直到无序子文件中不包含任何记录。

假定待排序文件由$n$条记录组成，记录依次存储在$r[1] \sim r[n]$中。使用直接插入排序算法对待排序文件中的记录进行排序，具体处理流程如下：

1. 将待排序文件$r[1] \sim r[n]$划分为有序子文件$r[1]$和无序子文件$r[2] \sim r[n]$。
2. 在每趟排序时，将无序子文件中的首条记录赋予监视哨$r[0]$，从后至前依次访问有序子文件中的记录，并在访问每条记录$r[j]$时执行如下操作：
   - 如果所访问记录$r[j]$的排序关键字大于监视哨$r[0]$中记录的排序关键字，则将所访问记录$r[j]$后移一位，赋予$r[j+1]$；
   - 否则，将监视哨$r[0]$中的记录赋值到所访问记录的前一位置$r[j+1]$，终止对有序子文件的遍历，更新有序子文件范围和无序子文件范围（分别将有序子文件的结束位置和无序子文件的起始位置后移一位），结束该趟排序。
3. 如果无序子文件中仍然存在记录，重复执行第 (2) 步操作，否则，算法执行结束。

#### 示例 7-1：设计直接插入排序算法。根据上述直接插入排序算法执行过程，直接插入排序算法代码如下。

```cpp
void InsertSort(SqList *L) // 对待排序文件 L->r[] 中的记录进行直接插入排序
{
    int i, j;
    i = 2;
    while (i <= L->length) {
        L->r[0] = L->r[i];          // 将无序子文件的首条记录存入监视哨 r[0] 中
        j = i - 1;
        while (L->r[j].key > L->r[0].key) { // 判断当前访问记录 r[j] 与监视哨 r[0] 的大小
            L->r[j + 1] = L->r[j];         // 将当前所访问记录 r[j] 后移一位，赋予 r[j+1]
            j--;
        }
        L->r[j + 1] = L->r[0];       // 将监视哨 r[0] 赋值到所访问记录 r[j] 的后一位置 r[j+1]
        i++;
    }
}
```

直接插入排序算法中监视哨$r[0]$有以下两个作用：

1. 存储每趟排序中的待插入记录$r[j]$，以防止有序子文件最后一条记录$r[j-1]$后移时丢失待插入记录$r[j]$的数据。
2. 令内层 `while` 循环至少能够在$j=0$时终止，避免文件遍历过程中出现数组下标越界情况。

### 7.3.2 折半插入排序算法

折半插入排序算法是对直接插入排序算法的改进。折半插入排序算法与直接插入排序算法的不同在于，为待插入记录查找插入位置时，直接插入排序算法从前向遍历有序子文件，而折半插入排序算法采用折半查找方式查找有序子文件中最后一个排序关键字不大于待插入记录排序关键字的记录，然后将有序子文件中所有位于此记录后的记录全部后移，将待插入记录赋值到此记录的后一位置。

由于折半插入排序算法与直接插入排序算法都以“找到有序子文件中最后一个排序关键字不大于待插入记录的关键字的记录”作为记录查找条件，并且都将待插入记录赋予此记录的后一位置，因此，折半插入排序算法的每趟排序结果都与直接插入排序算法相同趟的排序结果相同。

需要注意的是，折半查找算法通常被用于找出有序查找表中的某条记录，但是，当有序查找表中存在多条被查找记录或不存在此记录时，应该如何找到不大于此记录的最后一條记录呢？根据折半查找算法执行过程可知，当查找表中不存在目标记录时，`high` 指向查找表中最后一个小于目标记录的记录。因此，如果在找到与目标记录相同的记录时，将所找到记录视为小于目标记录，继续执行查找；最终查找失败时，`high` 将指向最后一个不大于目标记录的记录。

#### 示例 7-2：折半插入排序算法代码如下。

```cpp
void BInsertSort(SqList *L) // 对待排序文件 L->r[] 中的记录执行折半插入排序
{
    int i, j, low, high, mid;
    i = 2;
    while (i <= L->length) {
        low = 1; high = i - 1;     // 确定有序子文件范围，即查找范围 L->r[low..high]
        while (low <= high) {      // 不断缩小查找范围
            mid = (low + high) / 2;
            if (L->r[mid].key < L->r[0].key) {
                high = mid - 1;     // 更新查找范围，前移查找范围上界
            } else {
                low = mid + 1;      // 更新查找范围，后移查找范围下界
            }
        }
        for (j = i - 1; j > high; j--) {
            L->r[j + 1] = L->r[j];  // 将有序子文件中查找范围内的记录后移
        }
        L->r[high + 1] = L->r[0];   // 将待插入记录赋值到查找范围的后一位置
        i++;
    }
}
```

### 7.3.3 希尔排序算法

希尔排序又称“缩小增量排序”，其因 D.L.Shell 于 1954 年提出而得名。希尔排序算法设计思想为：以预定间隔长度（又称为增量）$h$为依据，将待排序文件中的记录分成$h$组，并对每组记录进行直接插入排序，然后逐渐减少间隔长度$h$，重复上述记录分组、排序操作，直至$h$为 1，最后对所有记录进行直接插入排序。

#### 示例 7-3：希尔排序算法代码如下。

```cppp p
// 对待排序文件 L->r[1]~L->r[n] 中的记录执行希尔排序，h 为增量数组首地址
void shellSort(SqList *L, int *h, int number_of_h)
{
    int i, j, m, n, increment, temp;
    for (i = 1; i <= number_of_h; i++) {  // 需要进行 number_of_h 趟排序
        increment = h[i];                 // 本趟排序以 h[i] 作为增量
        for (j = 1; j <= increment; j++) {  // 需要对 increment 组记录进行直接插入排序
            m = j;
            while (m < L->length) {
                L->r[0] = L->r[m];           // 将无序子文件的首条记录存入监视哨 r[0] 中
                n = m + increment;           // 用 n 从后向前遍历本组记录
                while (n > 0 && L->r[n].key > L->r[0].key) {
                    L->r[n + increment] = L->r[n];  // 将当前所访问记录 r[j] 后移
                    n -= increment;               // n 指向本组中前一记录
                }
                L->r[n + increment] = L->r[0];  // 插入待插入记录
                m += increment;
            }
        }
    }
}
```

## 7.4 交换排序算法

交换排序算法的设计思想为：未完成排序的记录表中一定存在着逆序记录对，算法只要不断探索逆序记录对中的记录，这样当记录表中不再存在逆序记录对时，记录表就是排好序的最终结果。采用不同的逆序记录对探索方法可以得到不同交换排序算法。常用的交换排序算法主要分为冒泡排序算法和快速排序算法。

### 7.4.1 冒泡排序算法

冒泡排序算法的设计思想为：多次遍历待排序文件，在遍历过程中确定相邻记录是否构成逆序记录对，并交换所发现逆序记录对中的记录，直至待排序文件中不存在由相邻记录所构成的逆序记录对。

#### 示例 7-4：简单冒泡排序算法代码如下。

```cpp
void bubbleSort(SqList *L) // 对待排序文件 L->r[] 中的记录进行简单冒泡排序
{
    int i, j;
    RecType temp;
    for (i = 1; i < L->length; i++) {  // 共需 L->length-1 趟排序
        for (j = 1; j < L->length - i; j++) {
            if (L->r[j].key > L->r[j + 1].key) {
                temp = L->r[j];
                L->r[j] = L->r[j + 1];
                L->r[j + 1] = temp;
            }
        }
    }
}
```

#### 示例 7-5：改进后的冒泡排序代码如下。

```cpp
void bubbleSort(SqList *L)
{
    int i, j;
    RecType temp;
    int flag = 0;  // 用于标识每趟排序中是否发生记录交换
    for (i = 1; i < L->length; i++) {
        flag = 0;
        for (j = 1; j < L->length - i; j++) {
            if (L->r[j].key > L->r[j + 1].key) {
                temp = L->r[j];
                L->r[j] = L->r[j + 1];
                L->r[j + 1] = temp;
                flag = 1;  // 标识每趟排序中发生了记录交换
            }
        }
        if (flag == 0) break;  // 本趟排序没有发生记录交换，算法执行结束
    }
}
```

### 7.4.2 快速排序算法

在冒泡排序算法执行过程中，有序子文件始终位于待排序文件尾部，算法需要遍历无序子文件中的每条记录。如果在每趟排序之前都能够确定目标记录最终位置的大体范围，那么是否只需遍历此范围内的记录就能够确定目标记录的最终位置呢？基于此思想提出了快速排序算法。

快速排序算法的设计思想为：先将待排序文件视为一个较大的无序子文件，然后总是在每个无序子文件中选择一条记录作为主元，通过比较主元和无序子文件中的其他记录以及交换无序子文件中记录的方式，确定主元最终位置，并实现对无序子文件的划分（主元前面元素都不大于主元，主元后面元素都不小于主元）。重复上述操作，直至每个无序子文件中只存在一条记录。

在快速排序算法执行过程中，主元位置的确定实现了对无序子文件的划分，将无序子文件划分成一个（主元最终位置在无序子文件首部或尾部）或两个（主元最终位置不在无序子文件首部和尾部）规模较小的无序子文件。由于无序子文件的规模总是在不断减小，因此，一定会出现每个无序子文件中只存在一条记录的场景，算法运行得以结束。假定待排序文件由$n$条记录组成，记录依次存储在$r[1] \sim r[n]$中。使用快速排序算法对待排序文件中的记录进行排序，具体处理流程如下：

1. 将待排序文件视为无序子文件，标识无序子文件位置$low = 1$，$high = n$。
2. 对每个无序子文件$r[low] \sim r[high]$执行如下操作：
   - 首先，选取无序子文件中的首条记录$r[low]$作为主元，记录主元以及无序子文件的起始位置和截止位置（$r[0] = r[low]$，$i = low$，$j = high$），然后使用变量$j$从前至后遍历无序子文件，使用变量$i$从前至后遍历无序子文件，直至$i$与$j$相等。
   - 如果直至遍历结束（$j = i$）都未发现排序关键字小于主元排序关键字的记录，将主元$r[0]$赋予$r[j]$，结束遍历；否则，一旦发现排序关键字小于主元排序关键字的记录$r[j]$，将当前所访问记录$r[j]$前置并赋予$r[j]$，且更新下一步遍历的起始位置（令$j = i + 1$）。
   - 更新无序子文件划分信息，并重新执行第 (2) 步，直至每个无序子文件都只包含一条记录。

#### 示例 7-6：快速排序算法代码如下。

```cpp
void sort(SqList *L, int low, int high)
{
    int i, j;
    i = low; j = high;
    if (i < j) {
        L->r[0] = L->r[i];  // 将主元保存到 r[0] 中
        while (i != j) {
            while (i < j && L->r[j].key >= L->r[0].key) j--;  // 用 j 实现无序子文件从后至前的遍历
            if (i < j) {
                L->r[i++] = L->r[j];  // 将当前所访问记录 r[j] 赋予 r[i]
            }
            while (i < j && L->r[i].key <= L->r[0].key) i++;  // 用 i 实现无序子文件从前至后的遍历
            if (i < j) {
                L->r[j--] = L->r[i];  // 将当前所访问记录 r[i] 赋予 r[j]
            }
        }
        L->r[j] = L->r[0];  // 将主元赋予 r[j]，划分无序子文件
        sort(L, low, j - 1);  // 递归排序主元左、右子文件
    }
}

void quickSort(SqList *L) // 对待排序文件 L->r[] 中的记录执行快速排序
{
    if (L->length > 1) {
        sort(L, 1, L->length);
    }
}
```

## 7.5 选择排序算法

选择排序算法是一种简单、直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后从剩余的末排序元素中寻找到最小（大）元素，然后放到已排序序列的末尾。依此类推，直到全部待排序数据元素的个数为 0。

### 7.5.1 简单选择排序算法

简单选择排序算法的设计思想为：将待排序文件划分为有序子文件和无序子文件两个部分，依次将无序子文件中具有最小排序关键字的记录置于有序子文件尾部，直至无序子文件只包含一条记录。

具体而言，简单选择排序算法执行过程如下：

1. 将待排序文件划分为不包含任何记录的有序子文件和包含所有记录的无序子文件，有序子文件位于无序子文件之前。
2. 从前至后遍历无序子文件，找出无序子文件中具有最小排序关键字的记录，将此记录与无序子文件中的首条记录交换。
3. 更新有序子文件和无序子文件的规模（有序子文件的规模加 1，无序子文件的规模减 1），如果更新后的无序子文件只包含 1 条记录，算法执行结束；否则，重复执行第 (2) 步。

#### 示例 7-7：简单选择排序算法代码如下。

```cpp
void selectSort(SqList *L) // 设置 i、j 的初始值
{
    int min, i, j;
    RecType temp;
    for (i = 2; i <= L->length; i++) {  // 共需执行 L->length-1 趟排序
        min = i;                        // min 指向无序子文件中的第一条记录
        for (j = i + 1; j <= L->length; j++) {  // 从无序子文件第二个记录起遍历无序子文件
            if (L->r[j].key < L->r[min].key) min = j;  // 遍历过程中不断更新 min
        }
        if (min != i) {
            temp = L->r[i];
            L->r[i] = L->r[min];
            L->r[min] = temp;
        }
    }
}
```

### 7.5.2 树状选择排序算法

树状选择排序算法又称锦标赛排序算法，在竞技比赛中经常使用。树状选择排序算法的设计思想为：首先将待排序文件中的记录进行两两分组，选出每组中的优胜记录，组成新的待排序文件，然后重复上述分组、选择、组合过程，当待排序文件中只有一条记录时，此记录就是原始待排序文件中的最小记录。在查找剩余记录中的最小记录时，算法可以充分利用现有比较结果，将最小记录原始位置设为极大值，只重走所选出最小记录的竞争轨迹。

### 7.5.3 堆排序算法

在介绍堆排序之前，先给出堆的定义：$n$个序列元素$\{k_1, k_2, \cdots, k_n\}$，当且仅当满足如下关系时，被称为堆。

$$
\begin{cases}
k_i \leqslant k_{2i}, & \text{或者} \\
k_i \leqslant k_{2i+1}, & \text{其中 } 1 \leqslant i \leqslant \frac{n}{2}
\end{cases}
$$

堆是一个具有如下性质的完全二叉树：每个结点的值都不小于其左、右孩子的值（大顶堆）或者每个结点的值都不大于其左、右孩子的值（小顶堆）。图 7.10(a) 和图 7.10(b) 分别表示大顶堆和小顶堆。

堆排序是利用堆的特性进行排序的方法，其基本思想是：首先将待排序记录构造为堆，然后将堆顶记录（键值最大记录）输出，再将剩余记录重新构造为堆，重复“输出堆顶—构造堆”过程，直到堆中只剩一条记录。

以大顶堆为例，堆排序具体分为以下 3 步：

1. 将所有待排序序列构造成一个堆，此时堆顶为键值最大的记录。
2. 将堆顶记录输出，通常将堆顶记录和最后一个记录交换。
3. 将剩余记录再调整成堆，重复第 (2) 步。

可见，堆排序需要解决两个问题：①如何将一个无序序列构建成一个堆；②输出堆顶记录后，如何调整剩余元素构建一个新堆。

#### 示例 7-8：堆排序算法代码如下。

```cpp
// 堆结构定义
typedef SqList HeapType;  // 堆采用顺序表存储

// 堆调整算法
void HeapAdjust(HeapType *H, int s, int m)
{
    int left = 2 * s + 1;  // 结点 i 的左孩子
    int right = 2 * s + 2; // 结点 i 的右孩子
    int largest = s;       // 结点 i 和左、右孩子 3 个结点中的键值最大记录
    if (left <= m && H->r[left].key > H->r[s].key) {
        largest = left;
    }
    if (right <= m && H->r[right].key > H->r[largest].key) {
        largest = right;
    }
    if (largest != s) {
        RecType temp = H->r[s];
        H->r[s] = H->r[largest];
        H->r[largest] = temp;
        HeapAdjust(H, largest, m);  // 递归调用
    }
}

// 堆排序算法
void HeapSort(HeapType *H)
{
    RecType temp;  // temp 用于交换记录，i 为被调整结点
    for (i = H->length / 2; i >= 1; i--) {
        HeapAdjust(H, i, H->length);  // 从后向前调整叶子结点
    }
    for (i = H->length; i > 1; i--) {
        temp = H->r[1];
        H->r[1] = H->r[i];
        H->r[i] = temp;
        HeapAdjust(H, 1, i - 1);  // 输出堆顶记录并调整堆
    }
}
```

## 7.6 归并排序算法

归并排序算法主要基于“归并”操作完成排序，“k-路归并”即将$k (k \geqslant 2)$个有序序列合并的过程。2-路归并排序的基本思想是：将待排序序列分成两个部分，对每个部分递归地应用归并排序，两个部分都排好序后再对它们进行归并。假设待排序序列长度为$n$，2-路归并排序算法具体执行步骤如下。

第一步：判定待排序序列长度，如果待排序序列长度为 1，直接返回当前序列，否则进入第二步操作。

第二步：将待排序序列划分为两个长度分别为$\lfloor n/2 \rfloor$和$\lceil n/2 \rceil$的子序列，并递归执行 2-路归并排序算法对所获得的两个子序列分别进行排序，从而得到两个有序子序列。

第三步：合并所获得的两个有序子序列，并确保合并后的结果依然有序。在此过程中，通常需要开辟一个长度为$n$的临时存储空间，以存放子序列合并过程中的中间结果。此外，需要在合并结束后将临时存储空间中的数据复制到待排序序列空间。

假定$r[s] \sim r[m]$和$r[m+1] \sim r[t]$是归并排序中需要合并的两个子序列，以$se[s] \sim se[t]$表示合并过程中所用到的临时空间，$r[s] \sim r[m]$和$r[m+1] \sim r[t]$的合并过程如下。

1. 初始化指针$i, j, k$，令上述 3 个指针分别指向子序列$r[s] \sim r[m]$、子序列$r[m+1] \sim r[t]$和临时空间$se[s] \sim se[t]$的首条记录的位置，即$i = s$，$j = m+1$，$k = s$。
2. 比较$r[i]$和$r[j]$的大小，将$r[i]$和$r[j]$中具有较小排序关键字的记录存入$se[k]$（当$r[i]$和$r[j]$的排序关键字相等时，将$r[i]$存入$se[k]$），然后将$se[k]$来源记录所对应的指针$i$或$j$后移一位，同时后移指针$k$。
3. 如果指针$i$超出所对应子序列的范围，即$i > m$，将子序列$r[j] \sim r[t]$复制到$se[k] \sim se[t]$；如果指针$j$超出所对应子序列的范围，即$j > t$，将子序列$r[i] \sim r[m]$复制到$se[k] \sim se[t]$；如果指针$i$和$j$均未超出各自所对应子序列的范围，重复执行第 (2) 步操作。

#### 示例 7-9：归并排序算法代码如下。

```cpp
// 合并两个有序序列 arr[low]~arr[mid] 和 arr[mid+1]~arr[high]
void Merge(int arr[], int low, int mid, int high)
{
    int i = low, j = mid + 1, k = 0;
    int *temp = (int *)malloc((high - low + 1) * sizeof(int));  // temp 数组暂存合并的有序序列

    while (i <= mid && j <= high) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }

    while (i <= mid) temp[k++] = arr[i++];
    while (j <= high) temp[k++] = arr[j++];

    for (i = low; i <= high; i++) {
        arr[i] = temp[i - low];
    }

    free(temp);  // 释放内存
}

// 对数组元素 arr[low]~arr[high] 进行归并排序
void MergeSort(int arr[], int low, int high)
{
    if (low >= high) return;  // 终止递归的条件，子序列长度为 1
    int mid = low + (high - low) / 2;  // 取得序列中间的元素
    MergeSort(arr, low, mid);          // 对左半边递归
    MergeSort(arr, mid + 1, high);     // 对右半边递归
    Merge(arr, low, mid, high);        // 合并
}
```

## 7.7 分配排序算法

本章 7.3 节～7.6 节介绍了插入排序算法、交换排序算法、选择排序算法和归并排序算法，这些排序算法通过比较关键字来确定记录间的先后顺序。本节将介绍分配排序算法，此类算法无需比较记录的关键字，而是通过额外的空间“分配”和“收集”记录，从而实现时间复杂度为$O(n)$的排序算法。

### 7.7.1 桶排序算法

桶排序（Bucket Sort）也称为箱排序（Bin Sort）。桶是能容纳多个记录的容器，桶中的记录个数不确定，因此采用链式结构存储记录较为合理。假定待排序序列$r[1] \sim r[n]$中所有记录关键字都是在闭区间$[a, b]$的整数，则$r[1]$个桶中记录的关键字范围在闭区间$[a + (b-a)/k, a + i(b-a)/k]$。接着根据记录关键字所属区间，依次将待排序记录分配到相应的桶中，将每个桶中的记录进行排序，最后顺序收集各个桶里的记录，得到按记录关键字排列的有序序列。

### 7.7.2 基数排序算法

基数排序算法可以看作是桶排序算法的一种推广和改进。借助桶，将待排序序列分成若干子序列，在某个时刻将得到的子序列收集起来。与前面基于比较的排序算法不同，基数排序算法排序过程中不需要进行不同记录关键字的比较。基数排序的基本思想为：使用桶，依据（子）序列中各记录关键字的每一位数值分配记录到对应桶中，将记录分成若干子序列，根据关键字的次高位进行排序，将其又分成若干子序列，每个子序列记录关键字的最高两位相同；按这种方式，直到完成按最低位的排序，将待排序序列分成很多子序列，最后一次性将这些子序列顺序收集起来完成记录序列的排序。这类方法被称为最高位优先基数排序（most-significant digit radix sort, MSD）。

另一种基数排序算法是按关键字最低位到最高位的顺序实现排序的。根据关键字的每一位进行一趟排序，每一趟都需要做一次分配与收集操作：使用桶，将待排序记录序列分成各子序列，接着将各子序列顺序收集起来，更新待排序记录的记录序列。这样依据关键字的每一位都做一趟排序后，即可完成记录序列的排序。这类方法被称为最低位优先基数排序（least-significant digit radix sort, LSD）。

## 7.8 各种排序技术比较

### 表 7.4 排序算法性质汇总

| 排序算法 | 最坏情况下时间复杂度 | 平均情况下时间复杂度 | 最好情况下时间复杂度 | 空间复杂度 | 稳定性 |
|----------|-----------------------|----------------------|-----------------------|------------|---------|
| 直接插入排序 |$O(n^2)$|$O(n^2)$|$O(n)$|$O(1)$| 稳定 |
| 折半插入排序 |$O(n^2)$|$O(n^2)$|$O(n \log n)$|$O(1)$| 稳定 |
| 希尔排序 |$O(n^2)$|$O(n^{1.25})$|$O(n)$|$O(1)$| 不稳定 |
| 冒泡排序 |$O(n^2)$|$O(n^2)$|$O(n)$|$O(1)$| 稳定 |
| 快速排序 |$O(n^2)$|$O(n \log n)$|$O(n \log n)$|$O(\log n)$| 不稳定 |
| 简单选择排序 |$O(n^2)$|$O(n^2)$|$O(n^2)$|$O(1)$| 不稳定 |
| 树状选择排序 |$O(n^2)$|$O(n \log n)$|$O(n \log n)$|$O(n)$| 不稳定 |
| 堆排序 |$O(n \log n)$|$O(n \log n)$|$O(n \log n)$|$O(1)$| 不稳定 |
| 归并排序 |$O(n \log n)$|$O(n \log n)$|$O(n \log n)$|$O(n)$| 稳定 |
| 链式基数排序 |$O(n+r) \cdot d$|$O(n+r) \cdot d$|$O(n+r) \cdot d$|$O(r)$| 稳定 |

---

### 1. 时间性能

一般而言，简单排序算法（如直接插入排序算法、简单选择排序算法和冒泡排序算法）比复杂排序算法（如快速排序算法、归并排序算法、堆排序算法等）的时间复杂度更高，但是实现更简单。如果待排序的序列很短，采用简单排序算法就足够了；但如果待排序的序列很长，则需要使用某种高效的排序算法，以保证算法的时间效率。

表 7.4 中排序算法按平均的时间性能可分为以下 3 类：

- **时间复杂度为$O(n \log n)$的算法**：快速排序算法、堆排序算法和归并排序算法，其中快速排序算法被认为是最快的一种排序算法；后两者相比较，在$n$值较大的情况下，归并排序算法比堆排序算法时间性能更好。
- **时间复杂度为$O(n^2)$的算法**：插入排序算法、冒泡排序算法和选择排序算法等，其中以插入排序算法最为常用，并且尤其适用于已按关键字基本有序排列的记录序列。选择排序过程中记录移动次数最少。
- **时间复杂度为$O(n)$的排序方法**：只有基数排序法。基数排序的时间复杂度虽然与待排序记录的个数呈线性关系，但它需要占用$O(rd)$的附加空间，其中$r$是基数，$d$是关键字的位数。

### 2. 空间性能

算法的空间性能是指排序过程中所需的辅助空间大小。

- 所有的简单排序算法（包括插入、冒泡和选择排序）和堆排序的空间复杂度均为$O(1)$。
- 快速排序算法的空间复杂度为$O(n \log n)$，它是递归程序执行过程中栈所需的辅助空间。
- 归并排序和基数排序算法所需辅助空间最多，其空间复杂度为$O(n)$。

### 3. 排序算法的稳定性
稳定的排序算法是指对于两个关键字相等的记录在经过排序之后，不改变它们在排序之前在序列中的相对位置。

- 除希尔排序算法、快速排序算法、简单选择排序算法、树状选择排序算法和堆排序算法是不稳定的排序算法外，本章讨论的其他排序算法都是稳定的。

- “稳定性”是由算法本身决定的。一般来说，排序过程中所进行的比较操作和交换数据仅发生在相邻的记录之间；没有大步距的数据调整时，则排序算法是稳定的。简单排序算法多是稳定的，但大多数时间性能较好的排序算法都不稳定，只有归并排序算法能很自然地得到稳定性。

复杂排序算法中，最终也可能需要对比较短的序列进行排序，故实际程序库中的排序函数通常都不是纯粹地采用一种算法，而是使用两种或两种以上方法的组合，如归并排序算法与插入排序算法的组合，以及快速排序算法与插入排序算法的组合等。

# 第 8 章 查找

## 8.1 查找概述

### 8.1.1 查找基本概念

- **查找表**: 查找表是由同一类型数据元素（或记录）构成的集合，例如电话号码簿和字典都可以看作一张查找表。查找表可以根据实际情况采取不同的数据结构来表示，例如线性表、树表以及散列表等。
- **关键字**: 关键字是可以标识数据元素的数据项。若一个关键字可以唯一标识一个数据元素，则称其为主关键字 (Primary Key)。若一个关键字可以识别若干数据元素，则称其为次关键字 (Secondary Key)。当数据元素中只有一个数据项时，其关键字即为该数据元素的值。
- **查找**: 查找是根据给定的某个值，确定查找表中是否存在关键字等于该值的记录或数据元素。若表中存在这样的记录，则称查找成功；否则称查找失败。若查找成功，则返回该数据元素的全部信息或返回该数据元素在表中的位置；若查找失败，则返回空值或空指针。
- **静态查找表**: 静态查找表对查找表的操作仅限于查找和检索，即静态查找表的内容不允许发生改变。
- **动态查找表**: 动态查找表对查找表的操作不仅允许执行查找和检索操作，还允许在查找过程中插入或删除表中的元素，即动态查找表的内容允许发生改变。换言之，动态查找表是在查找过程中动态生成的。

### 8.1.2 查找操作性能分析

查找操作的性能分析主要考虑时间复杂度，整个查找过程的主要开销在于给定关键字值和查找表中数据元素关键字值的比较上。一般称关键字值比较次数的数学期望值为平均查找长度 (Average Search Length, ASL)，并用其来衡量查找算法的性能。查找成功时，平均查找长度的定义为：

$$
ASL = \sum_{i=1}^{n} P_i C_i
$$

其中：
-$n$为查找表中数据元素的个数；
-$P_i$为查找第$i$个数据元素的概率且有$\sum_{i=1}^{n} P_i = 1$，通常假设每个数据元素查找概率相等，即$P_i = \frac{1}{n}$；
-$C_i$为找到表中其关键字与给定值相等的第$i$个记录时，与给定值已进行过比较的关键字个数。显然，$C_i$随查找过程不同而不同。

不难看出，一个算法的 ASL 越大，说明其查找性能越差；反之，其查找性能越好。

---

## 8.2 线性表的查找技术

### 8.2.1 顺序查找算法

对于以线性表表示的查找表，我们很容易想到顺序查找的思想，即从表的一端开始，顺序扫描线性表，依次将扫描到的结点关键字值与给定关键字 ($key$) 值进行比较。若当前扫描到的记录关键字值与$key$相等，则称查找成功；若扫描到表的另一端还没有找到关键字相同的记录，则称查找失败。顺序查找既适用于顺序表，也适用于链表。下面以顺序表为例来给出顺序查找的算法。

数据元素类型定义如下：

```cpp
typedef struct {
    KeyType key;       // 关键字域
    InfoType otherInfo; // 其他数据域
} ElementType;
```

顺序表 ST 的类型定义如下：

```cpp
#define MaxLength 10000
typedef struct {
    ElementType *elem; // 下标: 0, 1, ..., MaxLength-1
    int length;        // 表长
} SeqList;
```

假设顺序表 ST 的第一个存储单元不保存数据，即$ST.elem[0]$闲置，从$ST.elem[1]$开始顺序存放数据。

**例 8-1: 顺序查找算法如下。**

```cpp
int SeqSearch(SeqList ST, KeyType key) {
    // 在顺序表 ST 中顺序查找其关键字等于 key 的数据元素
    // 若找到，则函数值为该元素在表中的位置，否则为 0
    for(int i=ST.length; i>=1; i--) {
        if(ST.elem[i].key == key)
            return i; // 从后往前查找
    }
    return 0;
}
```

在查找过程中为了防止超越顺序表的边界，每次循环都要判断$i \leq ST.length$是否成立，这样会影响算法性能，因此我们可以对此进行优化。优化方法是在查找开始前将待查找数据元素的关键字 ($key$) 值赋予$ST.elem[0].key$，并以逆序方式从$ST.elem[ST.length]$开始查找。由于$ST.elem[0]$处于顺序表的边界，因此$ST.elem[0]$起到“哨兵”的作用，既可以防止越界情况产生，又可以消除每次循环需要对是否产生越界进行比较的开销，提高算法效率。

**例 8-2: 优化后的顺序查找算法如下。**

```cpp
int SeqSearch(SeqList ST, KeyType key) {
    // 若找到，则函数返回该元素在表中的位置，否则返回 0
    ST.elem[0].key = key;          // 设置“哨兵”
    int i = ST.length;
    for(; ST.elem[i].key != key; i--); // 从后向前查找
    return i;
}
```

优化算法通过设置“哨兵”，避免每次循环都检测整个表是否查找完毕，从而提高算法效率。实践证明，该改进方法可以在顺序查找的数据量较大时 ($ST.length \geq 10000$)，将完成一次查找所需的时间缩短几乎一半。

假设$n = ST.length$，不难看出例 8-1 和例 8-2 的时间复杂度一样，均为$O(n)$。假设每个记录的查找概率相等，可以得到顺序查找的平均查找长度为：

$$
ASL = \frac{1}{n} \sum_{i=1}^{n} (n - i + 1) = \frac{n + 1}{2}
$$

若表中各个记录的查找概率不相等，且此时能得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由小到大排列，以提高查找效率。若无法预先测定每个记录的查找概率，则可以在每个记录中附设一个访问频度域，并使顺序表中的记录始终保持按访问频度非递减有序排列，使得查找概率大的记录在查找过程中不断往后移，以便在以后的查找中减少比较次数，或者在每次查找之后都将刚查找到的记录直接移至表尾。

值得注意的是，上述针对平均查找长度的讨论是基于每次查找都“成功”的前提下进行的。但是查找有可能成功，也有可能失败。在实际情况中，查找成功的概率比查找失败的概率要大，尤其是当表中记录数$n$很大时，查找失败的概率往往可以忽略不计。但当查找失败的概率不能忽略时，查找算法的平均查找长度应为查找成功的平均查找长度和查找失败的平均查找长度之和。以上面的顺序查找为例，显然不论给定值$key$为多少，查找不成功时和给定值比较的次数均为$n + 1$。假设查找成功和查找失败的概率相同（各为$1/2$），对每个记录的查找概率也相等，则$P_i = 1/2n$，此时顺序查找的平均查找长度为：

$$
ASL_s = \frac{1}{2n} \sum_{i=1}^{n} (n - i + 1) + \frac{1}{2}(n + 1) = \frac{3}{4}(n + 1)
$$

顺序查找的优点是：算法简单，适用面较广；另外对表的结构也没有要求，不要求查找表按关键字有序。其缺点是：平均查找长度较大，查找效率较低。因此，当问题规模较大时，不宜采用顺序查找。

### 8.2.2 折半查找算法

```cpp
int BinarySearch(SqList ST, KeyType key) {
    // 在有序表 ST 中查找其关键字为 key 的元素
    // 若找到，则函数返回该元素在表中的位置，否则返回 -1
    int low = 0, high = ST.length - 1;      // 置区间初值
    while(low <= high) {
        int mid = (low + high) / 2;
        if(ST.elem[mid].key == key)         // 查找成功
            return mid;
        else if(ST.elem[mid].key < key)     // 继续在后半区间中查找
            low = mid + 1;
        else                                // 继续在前半区间中查找
            high = mid - 1;
    }
    return -1;                              // 表中不存在待查元素，查找失败
}
```

借助判定树很容易求得折半查找的平均查找长度。假设有序表的长度$n = 2^h - 1$，则其判定树为一棵深度$h = \log(n+1)$的满二叉树，树中层次为 1 的结点有 1 个、层次为 2 的结点有 2 个……层次为$h$的结点有$2^{h-1}$个。假设表中所有结点查找概率相等 ($P_i = 1/n$)，可得查找成功时折半查找的平均查找长度为：

$$
ASL = \sum_{i=1}^{n} P_i C_i = \frac{1}{n} \sum_{j=1}^{h} j \cdot 2^{j-1} = \frac{n+1}{n} \log_2(n+1) - 1
$$

当$n$较大时，上式可近似为：

$$
ASL \approx \log_2(n+1) - 1
$$

因此，折半查找的时间复杂度为$O(\log n)$，其查找效率远高于顺序查找。但折半查找只适用于有序表，且要求使用顺序存储结构。值得注意的是，当以有序表表示静态查找表时，除了折半查找方法之外，还有斐波那契查找和插值查找。

### 8.2.3 索引查找算法

索引查找算法思想如下：

1. 选取各块中的最大关键字构成一个索引表。
2. 查找分两个部分：先对索引表进行折半查找或顺序查找，以确定待查记录在具体哪一块中，然后在已确定的块中用顺序查找法进行查找。

需要注意的是，算法的思想是将$n$个数据元素 “按块有序” 划分为$m$块 ($m \leq n$)。每一块中的数据元素不必有序，但块与块之间必须 “按块有序”，即每个块的最大元素小于下一块的最小元素。因此，给定一个待查找记录的$key$，在查找这个$key$值位置时，会先去索引表中利用顺序查找或者折半查找来找出这个$key$所在块的索引起始位置，然后根据所在块的索引起始位置开始查找这个$key$所在的具体位置。

索引查找由索引表查找和块内查找两步完成。设$n$个数据元素的查找表均匀地分为$m$块，且每块含有$t$个元素，即$m = \lceil \frac{n}{t} \rceil$。如果索引表和块内均采用顺序查找，则平均查找长度为：

$$
ASL = ASL_{\text{索引}} + ASL_{\text{块内}} = \frac{1}{2}(m + 1) + \frac{1}{2}(t + 1) = \frac{1}{2}\left(\frac{n}{t} + t\right) + 1
$$

可见，索引查找的平均查找长度不仅与表长$n$有关，还与每一块中的记录个数$t$有关。在表长$n$确定的情况下可以证明，当$t = \sqrt{n}$时，$ASL$达到最小值$\sqrt{n} + 1$。这个值比顺序查找有了很大改进，但还远不及折半查找。

如果索引表使用折半查找、块内用顺序查找，则平均查找长度为：

$$
ASL = ASL_{\text{索引表}} + ASL_{\text{块内}} \approx \log_2(m + 1) - 1 + \frac{1}{2}(t + 1)
$$

索引查找需要划分块建立分块索引表，同时要求索引表有序，而块内可以无序。其查找效率介于折半查找和顺序查找之间。

---

## 8.3 树表的查找技术

### 8.3.1 二叉排序树

##### 1. 二叉排序树的定义

上节提到的折半查找判定树拥有这样的性质：根结点是整个区间的中点，根结点的孩子是两个子区间的中点。同时，由于查找的区间是有序的，因此每个结点的关键字值都大于左孩子的关键字值，并且小于右孩子的关键字值。拥有上述性质的二叉树称为二叉排序树 (Binary Sort Tree, BST)，也叫二叉搜索树。下面给出二叉排序树的严格定义：二叉排序树或者是一棵空树，或者是拥有下列性质的非空二叉树。

1. 若左子树非空，则左子树上所有结点关键字值均小于根结点关键字值。
2. 若右子树非空，则右子树上所有结点关键字值均大于根结点关键字值。
3. 左、右子树也分别是一棵二叉排序树。

二叉排序树结点结构的定义如下：

```cpp
typedef struct {
    ElemType data;
    struct Node *lchild, *rchild;
} BSTNode, *BSTree;
```

##### 2. 二叉排序树的查找

二叉排序树的查找是从根结点开始，沿某一路径逐层向下查找的过程。由二叉排序树的递归定义，很容易给出二叉排序树查找的递归算法。其算法思想如下：

1. 若二叉树为空，则查找失败。
2. 若二叉树非空，则将$key$值和根结点的关键字比较。
   - 若相等，则查找成功。
   - 若根结点关键字大于$key$值，则在左子树中查找，否则在右子树中查找。

**例 8-4: 二叉排序树查找递归算法如下。**

```cpp
// 递归版 BST 查找算法
BSTNode* BSTSearch(BSTNode* root, KeyType key) {
    if(root == NULL)
        return NULL;
    if(key > root->data.key)           // 查找右子树
        return BSTSearch(root->rchild, key);
    else if(key < root->data.key)      // 查找左子树
        return BSTSearch(root->lchild, key);
    else
        return root;
}
```

##### 3. 二叉排序树的插入

二叉排序树的插入是以查找为基础的。要将一个关键字值为$key$的结点插入二叉排序树中，则需要从根结点向下寻找，当树中不存在关键字等于$key$的结点时才进行插入。新插入的结点一定是一个新添加的叶子结点，并且它的父亲结点是查找失败的路径上访问的最后一个结点。

二叉排序树插入关键字为$key$的结点，其算法思想如下：

1. 若二叉排序树为空，则将结点作为根结点插入树中。
2. 若二叉排序树不为空，则比较$key$与根结点关键字的大小。
   - 若$key = T->data.key$，则停止插入。
   - 若$key < T->data.key$，则插入左子树中。
   - 若$key > T->data.key$，则插入右子树中。

**例 8-6: 二叉排序树插入递归算法如下。**

```cpp
bool InsertBST(BSTree &T, ElemType e) {
    if(T == NULL) {                    // 若为空树则作为根结点插入
        T = (BSTNode*)malloc(sizeof(BSTNode));
        T->data = e;
        T->lchild = T->rchild = NULL;
        return true;
    }
    else if(e.key == T->data.key)      // 否则查找找到插入位置后插入
        return false;
    else if(e.key < T->data.key)
        return InsertBST(T->lchild, e);
    else
        return InsertBST(T->rchild, e);
}
```

##### 4. 二叉排序树的创建

二叉排序树的创建是从初始状态为空的二叉排序树开始，通过不断调用二叉排序树插入算法函数，依次插入给定值的结点。

二叉排序树的创建算法思想如下：

1. 初始化一棵空二叉排序树。
2. 读入一个元素，根据元素的关键字，查找合适位置并插入结点。
3. 重复第 (2) 步，直至所有元素插入完成。

**例 8-7: 二叉排序树创建算法如下。**

```cpp
BSTNode* CreateBST(ElemType A[], int n) { // 数组 A 存放待插入数据
    BSTNode *T = NULL;
    int i = 0;
    while(i < n) {
        InsertBST(T, A[i]);
        i++;
    }
    return T;
}
```

##### 5. 二叉排序树的删除

删除操作是二叉排序树操作中最为复杂的操作。因为删除的可能是树上任何一个结点，而删除后仍然要保持二叉排序树的特性，所以需要修改被删除结点的父亲结点以及其他结点的指针。

二叉排序树删除结点的算法思想如下：

1. 若被删除结点$z$是叶子结点，直接删除$z$即可，不会破坏二叉排序树的性质。
2. 若被删除结点$z$仅有左孩子或仅有右孩子，则让$z$的孩子成为$z$父亲结点的子树，替代$z$的位置。
3. 若被删除结点$z$既有左孩子也有右孩子，则令$z$的直接后继（或直接前驱）替代$z$，然后从二叉排序树中删除这个直接后继（或直接前驱），这样就转换成了第一种或者第二种情况。简单来说，我们可以从当前删除结点$z$的右子树中找到最小的值（直接后继）来替代当前结点，因为该值为$z$的右子树中最左下结点一定没有左子树；或者，可以从当前删除结点$z$的左子树中找到最大的值（直接前驱）来替代当前结点，因为该值为$z$的左子树中最右下结点一定没有右子树。

**例 8-8: 二叉排序树删除操作算法如下。**

```cpp
// 删除操作。判断当前属于哪种情况:
// (1) 叶子结点；
// (2) 只有左子树或者只有右子树；
// (3) 既有左子树，又有右子树 /
bool DeleteBST(BSTree &BN) {
    // 要删的结点为叶子结点的情况
    if(BN->lchild == NULL && BN->rchild == NULL) {
        free(BN);
        BN = NULL;
    }
    // 要删的结点只有右子树的情况
    else if(BN->lchild == NULL) {
        tmp = BN;
        BN = BN->rchild;
        free(tmp);
    }
    // 要删的结点只有左子树的情况
    else if(BN->rchild == NULL) {
        tmp = BN;
        BN = BN->lchild;
        free(tmp);
    }
    // 要删的结点既有左子树，又有右子树的情况
    else {
        tmp = BN;
        BSTNode *s = BN->rchild;
        while(s->lchild != NULL) {
            tmp = s;
            s = s->lchild;
        }
        BN->data = s->data;
        if(tmp != BN)
            tmp->lchild = s->lchild;
        else
            tmp->rchild = s->lchild;
        free(s);
    }
    return true;
}
```

从查找过程看，二叉排序树与折半查找相似；就平均时间性能而言，二者也差不多；就维护表的有序性而言，二叉排序树无需移动结点，只需要修改指针即可完成插入和删除操作，插入和删除操作的平均时间复杂度为$O(\log n)$。折半查找的对象是顺序表，其插入和删除操作的时间复杂度为$O(n)$。当有序表是静态查找表时，宜用顺序表作为其存储结构，使用折半查找算法。当有序表是动态查找表时，使用二叉排序树作为查找表更为合适。

### 8.3.2 平衡二叉树

#### 1. 平衡二叉树的定义

平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树。

1. 左子树和右子树高度差的绝对值不超过 1。
2. 它的左子树和右子树也都是平衡二叉树。

平衡二叉树结点数据类型的定义如下：

```cpp
typedef struct {
    ElemType data;
    int height;
    struct Node *lchild, *rchild;
} AVLNode, *AVLTree;
```

#### 2. 平衡二叉树的插入

与二叉排序树相同，平衡二叉树的插入和删除操作也是一个查找的过程。不同的是，每当在平衡二叉树中插入（或删除）一个结点时，AVL 树中相关结点的平衡状态会发生改变，因此需要从插入位置沿通向根的路径回溯，检查各结点平衡因子的绝对值是否超过 1，若超过则表明该平衡二叉树已失衡。如果在某一结点发现平衡二叉树失衡，则停止回溯，并从发生失衡的结点起，检查该结点及其子结点的连接方式。它们的连接方式可以归类为 4 种情况（见图 8.12，在这里将中间结点叫作 pivot，它的子结点叫作 bottom，父亲结点叫作 root）。如果 pivot 是 root 的左结点（或者右结点），并且 bottom 也是 pivot 的左结点（或右结点），则采用单旋转的方式进行平衡化，单旋转又可按上述两种连接方式分为右单旋转和左单旋转两种情况。显然，它们互为镜像。如果 pivot 是 root 的左结点（或者右结点），而 bottom 却是 pivot 的右结点（或左结点），这类情况下需要采用双旋转的方式进行平衡化，双旋转又可按照上述两种连接方式分为先左后右双旋转和先右后左双旋转两种情况。

**例 8-9: 二叉平衡树结点插入算法（右单旋转）如下。**

```cpp
// 右单旋转
AVLNode* RotateRight(AVLTree p) {
    // p 指向初始根结点 A
    AVLTree lc;
    lc = p->lchild;                     // lc 指向新的根结点 B
    p->lchild = lc->rchild;             // 将 A 的左结点替换为 E
    lc->rchild = p;                     // 将 B 的右结点替换为 A
    return lc;
}
```

**例 8-10: 二叉平衡树结点插入算法（左单旋转）如下。**

```cpp
// 左单旋转
AVLNode* RotateLeft(AVLTree p) {
    // p 指向初始根结点 A
    AVLTree rc;
    rc = p->rchild;                     // rc 指向新的根结点 C
    p->rchild = rc->lchild;             // 将 A 的右结点替换为 D
    rc->lchild = p;                     // 将 C 的左结点替换为 A
    return rc;
}
```

**例 8-11: 二叉平衡树结点插入算法（先左后右双旋转）如下。**

```cpp
// 先左后右双旋转
AVLNode* RotateLeftRight(AVLTree p) {
    p->lchild = RotateLeft(p->lchild);  // 进行左单旋转
    return RotateRight(p);              // 进行右单旋转并返回 p
}
```

**例 8-12: 二叉平衡树结点插入算法（先右后左双旋转）如下。**

```cpp
// 先右后左双旋转
AVLNode* RotateRightLeft(AVLTree p) {
    p->rchild = RotateRight(p->rchild); // 进行右单旋转
    return RotateLeft(p);               // 进行左单旋转并返回 p
}
```

#### 3. 平衡二叉树的查找性能分析

在平衡二叉树上进行查找的过程与在二叉排序树上进行查找的过程相同，因此，查找过程中所进行的比较次数最多不超过树的深度。假设以$N_h$表示深度为$h$的平衡二叉树中含有的最少结点数，显然，$N_0 = 0$，$N_1 = 2$，并且有$N_h = N_{h-1} + N_{h-2} + 1$。可以证明，含有$n$个结点的平衡二叉树的最大深度为$\log n$，所以平衡二叉树的平均查找长度为$O(\log n)$。

---

## 8.4 散列表的查找技术

### 8.4.1 散列函数设计

散列函数的设计对于散列技术的实现至关重要。好的散列函数应该满足计算简单和分布均匀两个条件。其中计算简单指的是散列函数的计算时间不应该超过其他查找技术与关键字比较的时间，否则散列表就失去其优越性；分布均匀指的是散列地址应等概率、均匀地分布在在整个地址空间中，从而减少冲突的发生。

下面介绍几种常用的散列函数。

1. **直接定址法**

直接定址法直接取关键字的某个线性函数值为散列地址，散列函数为：

$$
f(key) = a \times key + b
$$

其中$a$、$b$为常数。直接定址法非常容易实现，并且由于散列函数是关键字的线性函数，因此不会发生冲突，适合关键字分布连续的情况。如果关键字分布不连续，空位较多，则会造成存储空间的浪费。

2. **数字分析法**

假设现有学生生日信息为：1997.02.13、1998.12.13、1997.05.06、1999.10.12…，经分析发现前 3 位分布不均匀，重复的可能性大。因此，应该选择分布较为均匀的后几位作为散列地址。显然，数字分析法只适用于已知关键字集合的情况。若更换了关键字集合，就需要重新分析。

3. **除留余数法**

此方法为最常用的构造散列函数方法。对于表长为$m$的散列表，取一个整数$p$，利用以下的散列函数把关键字转换成散列地址。

$$
f(key) = key \mod p
$$

除留余数法的关键是选好$p$，使得每个关键字经过散列函数转换后尽可能均匀地映射到散列空间中的任一地址。理论研究表明，除留余数法的模$p$取不大于表长$m$且最接近表长$m$的质数时，效果最好。

4. **平方取中法**

平方取中法是一种常用的散列函数构造方法。该方法先取关键字的平方，然后根据可使用空间的大小，选取平方数的中间几位作为散列地址。该方法得到的散列地址与关键字的每一位都有关系，散列地址分布比较均匀。这种方法适用于关键字每一位取值都不够均匀或小于散列地址所需位数的情况。

5. **折叠法**

折叠法是将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，作为散列地址。这种方法适用于关键字位数特别多的情况。

6. **随机数法**

随机数法设定散列函数为：

$$
H(key) = Random(key)
$$

其中，Random 为伪随机函数。此法适用于关键字长度不等的情况。

总之，实际造表时，采用何种方法构造散列函数取决于建表的关键字集合的情况（包括关键字的范围和形态），以及散列表长度（散列地址范围）。不论使用何种方法，都要使产生冲突的可能性尽可能小。

### 8.4.2 处理冲突的方法

需要注意的是，无论使用何种方法构造散列函数，都不可能完全避免冲突。因此，需要采取合适的方法来处理冲突，即为产生冲突的关键字寻找下一个空的散列地址。假设已经选定散列函数$f(key)$，用$d_i$表示发生冲突后第$i$次探测的散列地址。下面介绍几种常用的处理冲突方法。

#### 1. 开放定址法

开放定址法 (Open Addressing) 的主要思想是发生冲突时，直接寻找下一个空的地址（只要散列表足够大，就总能找到空的地址）。这种寻找下一个地址的行为叫做探测。其数学表达式为：

$$
f_i = (f(key) + d_i) \mod m
$$

其中，$i = 0, 1, 2, \cdots, k (k \leq m-1)$，$m$为表长，$d_i$为增量序列。根据增量序列$d_i$取法的不同，有以下多种探测方法：

1. 当$d_i = 0, 1, 2, \cdots, k(k \leq m-1)$时，称为线性探测 (Linear Probing) 再散列法。冲突发生时，顺序查看表中下一个单元，直到查找到一个空单元或查遍全表。线性探测法会导致如下现象，即发生冲突后，使用线性探测法将该同义词存入下一个单元，而本该存入该单元的非同义词只能继续顺序向后存储，这样会造成大量元素在相邻的散列地址附近堆积起来，产生“聚集”效应，从而破坏分布的均匀性。
2. 当$d_i = 0, 1^2, 2^2, -2^2, \cdots, k^2, -k^2$时，称为平方探测 (Quadratic Probing)，又称二次探测法。相较于线性探测再散列法，二次探测法相当于冲突发生时探测长度为$i^2$个单元，有限地避免了元素堆积的发生。其缺点是不能探测到散列表上全部单元，但至少能探测到一半单元。
3. 当$d_i$为伪随机数序列时，称为伪随机探测。

#### 2. 拉链法

开放定址法的原理是当冲突发生时寻找散列表中下一个空闲单元来存储同义词。但如果此时散列表内空间不足，既无法处理冲突也无法插入元素。这里介绍一种用数组和链表结合来处理冲突的方法——拉链法 (Chaining)。在拉链法中，散列地址为$i$的所有同义词都存储在一个链表上，此链表的头指针保存在散列表中第$i$个单元中。每次发生冲突后，只需要在对应的链表上新插入一个结点即可。因此，查找、插入和删除操作主要在同义词链表中进行。显然，拉链法适用于经常进行插入和删除的情况。假设有关键字序列为 \{18, 13, 24, 3, 20, 84, 55, 11\}，散列函数为$f(key) = key \mod 11$，采用拉链法处理冲突所建立的散列表如图 8.39 所示。

#### 3. 再散列法

此方法同时准备多个散列函数，当第一个散列函数发生冲突的时候可以用备选的散列函数进行计算，直到冲突不再发生。这种方法不易产生“聚集”，但增加了计算时间。

### 4. 公共溢出区法

此方法建立一个公共溢出区来存放所有产生冲突的关键字。在查找时，通过散列函数对给定关键字计算出散列地址后，先与基本表的相应位置进行比对。如果相等，则查找成功；如果不相等，则到溢出表中进行顺序查找。如果相较于基本表而言，有冲突的数据很少，此时公共溢出区法的查找性能还是较高的。

以下是将图片内容转换为标准 Markdown 格式，并使用 LaTeX 渲染公式的版本：

---

### 8.4.4 散列查找性能分析

#### 1. 线性探测再散列法等概率情况下查找成功和不成功时平均查找长度的计算

##### (1) 线性探测再散列法查找成功时的 ASL

待查找的数字肯定在散列表中才会查找成功。例如，现需要查找关键字 14，由于$H(14) = 14 \% 7 = 0$，而散列表中地址 0 处的关键字为 14，则查找成功，比较次数为 1。又如现需要查找关键字 22，由于$H(22) = 22 \% 7 = 1$，而散列表中地址 1 处关键字为 1，不等于 22，但下一个地址 2 中关键字为 22，表明查找成功，比较次数为 2。对其他关键字进行类似处理，可以得到表 8.3 所示每一个关键字查找成功时的比较次数。

**表 8.3 线性探测再散列法查找成功时各关键字比较次数**

| 散列地址 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
|----------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| 关键字   | 14  | 1   | 22  |     | 11  | 19  | 55  | 68  | 82  | 40  |
| 比较次数 | 1   | 1   | 2   |     | 1   | 1   | 3   | 4   | 5   |     |

由此可得 9 个关键字序列在等概率情况下查找成功时的平均查找长度为：

$$
ASL_{succ} = \frac{1 + 1 + 2 + 1 + 1 + 3 + 4 + 5}{9} = \frac{19}{9}
$$

##### (2) 线性探测再散列法查找不成功时的 ASL

计算查找不成功时的比较次数可以直接统计从位置$i$到第一个地址上关键字为空的距离。由于待查找的关键字肯定不在散列表中，根据散列函数地址为$key \mod 7$，因此任何一个数经散列函数计算以后的初始地址只可能在$0 \sim 6$的位置，可得到 7 个位置在查找不成功时的探测次数表如表 8.4 所示。

- 地址 0，到第一个关键字为空的地址 3 需要比较 3 次，因此不成功的比较次数为 3；
- 地址 1，到第一个关键字为空的地址 3 需要比较 2 次，因此不成功的比较次数为 2；
- 地址 2，到第一个关键字为空的地址 3 需要比较 1 次，因此不成功的比较次数为 1；
- 地址 3，到第一个关键字为空的地址 3 需要比较 0 次，因此不成功的比较次数为 0；
- 地址 4，到第一个关键字为空的地址 3（比较到地址 6，再循环回去）需要比较 9 次，因此不成功的比较次数为 9；
- 地址 5，到第一个关键字为空的地址 3（比较到地址 6，再循环回去）需要比较 8 次，因此不成功的比较次数为 8；
- 地址 6，到第一个关键字为空的地址 3（比较到地址 6，再循环回去）需要比较 7 次，因此不成功的比较次数为 7。

**表 8.4 线性探测再散列法查找不成功时各位置比较次数**

| 散列地址 | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
|----------|-----|-----|-----|-----|-----|-----|-----|
| 比较次数 | 3   | 2   | 1   | 0   | 9   | 8   | 7   |

因此，可以计算得到 7 个位置在等概率情况下查找失败时的平均查找长度为：

$$
ASL_{unsucc} = \frac{3 + 2 + 1 + 9 + 8 + 7}{7} = \frac{30}{7}
$$

#### 2. 链地址法等概率情况下查找成功和不成功时 ASL 的计算

##### (1) 链地址法查找成功时的 ASL

假设在用链地址法解决冲突的过程中建立的散列表如表 8.5 所示，并可得到 9 个关键字序列 \(\{18, 13, 24, 3, 20, 84, 27, 55, 11\}\) 在查找成功时的探测次数。

**表 8.5 链地址法查找成功时各关键字比较次数**

| 关键字 | 18  | 13  | 24  | 3   | 20  | 84  | 27  | 55  | 11  |
|--------|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| 比较次数 | 1   | 1   | 2   | 1   | 1   | 2   | 1   | 1   | 2   |

由表 8.5 可以计算得到查找成功时的 ASL 为：

$$
ASL_{succ} = \frac{1 + 1 + 2 + 1 + 1 + 2 + 1 + 1 + 2}{9} = \frac{12}{9}
$$

##### (2) 链地址法查找不成功时的 ASL

由建立的散列表（见图 8.39）可知，查找不成功时，则：

- 查找地址为 0 的值所需要的比较次数为 2；
- 查找地址为 1 的值所需要的比较次数为 0；
- 查找地址为 2 的值所需要的比较次数为 2；
- 查找地址为 3 的值所需要的比较次数为 1；
- 查找地址为 4 的值所需要的比较次数为 0；
- 查找地址为 5 的值所需要的比较次数为 1；
- 查找地址为 6 的值所需要的比较次数为 0；
- 查找地址为 7 的值所需要的比较次数为 2；
- 查找地址为 8 的值所需要的比较次数为 0；
- 查找地址为 9 的值所需要的比较次数为 1；
- 查找地址为 10 的值所需要的比较次数为 0。

所以查找不成功时的 ASL 为：

$$
ASL_{unsucc} = \frac{2 + 2 + 1 + 2 + 1}{11} = \frac{9}{11}
$$

查找过程中，关键字的比较次数取决于产生冲突的多少。产生的冲突少，查找效率就高；产生的冲突多，查找效率就较低。因此，影响产生冲突多少的因素也就是影响查找效率的因素。影响产生冲突多少的主要有以下 3 个因素：

1. 散列函数是否均匀。
2. 处理冲突的方法。
3. 散列表的装填因子。

散列表的装填因子定义为：

$$
\alpha = \frac{\text{表中记录数 } n}{\text{散列表的长度 } m}
$$

其中，$\alpha$是散列表装满程度的标志因子。散列表的平均查找长度依赖于装填因子$\alpha$，而不直接依赖于$n$或$m$。直观地看，$\alpha$越大，说明表装得越满，发生冲突的可能性越大；反之，发生冲突的可能性越小。为了降低产生冲突的可能性，我们通常会将散列表的空间设置得比查找集合大。这个做法会浪费一定的空间，但是换得效率的提升，它是基于“用空间换时间”的思想。