# 第1章 数字电路与逻辑设计基础

## 1.1 芯片与数字电路

### 1.1.1 数字信号与系统

在科学和工程领域遇到的大多数信号是自然模拟信号。**模拟信号**是用连续变量的函数表示，这些连续变量（如时间或空间）通常在一个连续的范围取值。这类信号可以直接被合适的模拟。

**数字信号**是用离散变量的函数表示，这些离散变量（如时间或空间）在一个不连续的范围取值。数字信号处理系统提供了处理模拟信号的备用方法，如图 1.2 所示。要执行数字信号处理，必须将模拟信号转换为数字形式，即转换成具有有限精度的数字序列。模拟信号的数字化过程如图 1.3 所示。

#### 1. 采样

采样是指连续时间信号转换成离散时间信号的过程，其通过对连续时间信号在离散时间点处取样本实现。因此，如果 $x_a(t)$ 是采样器的输入，那么输出 $x_a(nT) = x(n)$，其中 $T$ 称为采样间隔或采样周期，采样频率 $F_s = 1/T$。

**采样定理**：根据奈奎斯特理论，采样频率不低于模拟信号最高频率 $F_{\text{max}}$ 的两倍，这样就能无失真地将信号还原成原来的模拟信号，即 $F_s \geq 2F_{\text{max}}$。

#### 2. 量化

量化是指离散时间连续值信号转换成离散时间离散值（数字）信号的转换过程。每个信号样本值是从可能值的有限集中选取的。未量化样本 $x(n)$ 和量化输出 $x_q(n)$ 之间的差称为量化误差。

#### 3. 编码

编码，即将每一个离散值 $x_q(n)$ 用一定位数的二进制序列表示，且位数越多，精度越高，需要的存储量越大；反之，位数越少，精度越低，需要的存储量就越小。

### 1.1.2 数字电路

用来处理数字信号的电子线路称为**数字电路**。由于数字电路的各种功能是通过逻辑运算和逻辑判断来实现的，因此数字电路又称为**数字逻辑电路**或**逻辑电路**。

#### 1. 数字电路的特点

数字电路与模拟电路相比，具有如下特点：

1. 数字电路的基本工作信号是二值信号。它表现为电路中电压的“高”或“低”、开关的“接通”或“断开”、晶体管的“导通”或“截止”等两种稳定的物理状态。
2. 数字电路中的半导体器件一般都工作在开、关状态。对电路进行分析时，主要分析输出和输入之间的逻辑关系。
3. 数字电路组成的基本单元结构简单、功耗低、便于集成制造和系列化生产，所以制造的产品价格低廉、使用方便、通用性好。
4. 由数字电路构成的数字系统运行速度快、精度高、可靠性好、功能扩展方便。

鉴于上述特点，数字电路已经大规模应用在几乎所有领域。随着半导体技术和工艺的发展，出现了数字集成电路，人们已不再用分立元件去构造实现各种逻辑功能的部件，而是采用标准集成电路进行逻辑设计。

#### 2. 数字集成电路

**表 1.1 集成电路按照规模进行分类**

| 类型 | 门电路数/个 | 元器件数/个 |
|------|-------------|-------------|
| SSI  | 10 以内     | 100 以内    |
| MSI  | 10 ~ 100    | 100 ~ 1000  |
| LSI  | 100 ~ 1000  | 1000 ~ 10 000 |
| VLSI | 1000 ~ 10 000 | 10 000 ~ 100 000 |
| ULSI | 10 000 ~ 100 000 | 100 000 ~ 1 000 000 |
| GSI  | > 1 000 000 | > 10 000 000 |

#### 3. 数字电路的类型

根据一个电路有无记忆功能，数字电路可分为**组合逻辑电路**（Combinational Logic Circuit）和**时序逻辑电路**（Sequential Logic Circuit）两种。

## 1.2 数制及其转换

## 1.3 二进制数的算术运算

在数字系统中，可以进行逻辑运算和算术运算。二进制数不仅可以表示不同的逻辑状态，而且也可以用于表示数量的大小，此时它们之间可以进行算术运算。

### 1.3.1 无符号二进制数的算术运算

二进制算术运算和十进制算术运算的规则基本相同，唯一的区别在于二进制数是“逢二进一，借一当二”，而不是十进制数的“逢十进一，借一当十”。其运算规则如下：

- **加法规则**
  - 0+0=0
  - 0+1=1
  - 1+0=1
  - 1+1=10（进位为 1）

- **减法规则**
  - 0-0=0
  - 0-1=1
  - 1-0=1
  - 1-1=0

- **乘法规则**
  - 0×0=0
  - 0×1=0
  - 1×0=0
  - 1×1=1

- **除法规则**
  - 0÷1=0
  - 1÷1=1

### 1.3.2 带符号二进制数的算术运算

#### 1. 原码

原码由符号位加上二进制数的绝对值构成，最高位为符号位，0 表示正数，1 表示负数，数值位为符号数真值的绝对值，又称为符号—数值表示法。例如，+5、-5 对应的原码为 8 位带符号二进制数。

#### 2. 反码

反码表示带符号的二进制数时，符号位与原码相同，也是用 0 表示正，1 表示负；数值位与符号位相关，正数反码的数值位和原码相同，而负数反码的数值位是在原码的基础上按位取反。

#### 3. 补码

补码表示带符号的二进制数时，符号位与原码相同，即用 0 表示正，1 表示负；正数补码的数值位与原码相同，负数补码的数值位则是在原码的基础上先按位取反，然后在最低位加 1。例如，采用补码进行加、减运算时，符号位和数值位一样参加运算。如果符号位有进位产生，则可以忽略不计。

## 1.4 几种常用的代码

### 1.4.1 十进制数的二进制码

#### 1. 8421 码

8421 码是最为常用的一种 BCD 码，它由 4 位二进制数 0000（0）～1001（9）组成，1010 ～ 1111 是无效码。8421 码是一种有权码，从高位至低位的权依次为 8、4、2、1，与普通的 4 位二进制数的权是一样的。因此，按 8421 码编码的 0 ～ 9 与用 4 位二进制数表示的 0 ～ 9 完全一样。

#### 2. 2421 码

2421 码也是一种有权码，对应 $W_3 \sim W_0$ 的权依次为 2、4、2、1。2421 码不具备单值性，为了与十进制数码一一对应，2421 码不允许出现 0101 ～ 1010 的 6 种编码。

#### 3. 5421 码

5421 码也是一种有权码，对应 $W_3 \sim W_0$ 的权依次为 5、4、2、1，不允许出现 0101、0110、0111、1101、1110、1111 这 6 种编码。

#### 4. 余 3 码

余 3 码是一种无权码，每一位没有固定的权值。余 3 码的每个编码比相应 8421 码多 3（0011），故称为余 3 码。同样地，余 3 码中也有 6 种编码 0000、0001、0010、1101、1110 和 1111 是不允许出现的。

### 1.4.2 可靠性编码

#### 1. 格雷码

##### 例 1.11  
求二进制码 `11001011` 对应的格雷码。

**解：** 按照式（1-4）求格雷码。

![S1](/note/media/s1.png)

所以有 `(11001011)₂ = (10101110)gray`。


##### 例 1.12  
求格雷码 `10011011` 对应的二进制码。

**解：** 按照式（1-5）求二进制码。

![S2](/note/media/s2.png)

所以有 `(10011011)gray = (11101101)₂`。

#### 2. 奇偶检验码

奇偶检验码由以下两个部分组成：一是信息位，即需要传递的源代码；二是奇偶检验位，它仅有一位。奇偶检验位的编码方式有两种：一种是使信息位和检验位中“1”的个数为奇数，称为**奇检验**；另一种是使信息位和检验位中“1”的个数为偶数，称为**偶检验**。例如，二进制代码 `1101100`，采用奇检验的检验位应为 `1`，而采用偶检验的检验位应为 `0`。表 1.5 列出了与 8421 码对应的奇偶检验码。

#### 3. 循环冗余校验码 (CRC)

**实例：** 已知多项式 $G(x) = x^4 + x + 1$，发送数据为 `111010`

① $G(x)$ 对应二进制串为 `10011`

② 发送数据后添加 $k-1$ 个 0：`111010 0000`

③ `1110100000` 模 2 除法（异或）除以 `10011` 得 `111110` 余 `0010`

④ 发送 `111010 0010`

# 第2章 逻辑代数基础

## 2.1 逻辑代数概述

## 2.2 逻辑运算

### 2.2.1 基本逻辑运算

#### 1. 或运算

在逻辑问题的描述中，如果决定某一事件发生的多个条件中，只要有一个或一个以上条件成立，事件便可发生，则称这种因果关系为或逻辑关系。在逻辑代数中，或逻辑关系用或运算描述。或运算又称逻辑加（Logic Addition），其运算符号为“+”，有时也用“∨”表示。两变量或运算的关系可表示为：

$$ F = A + B \quad \text{或者} \quad F = A \lor B $$

#### 2. 与运算

在逻辑问题中，如果决定某一事件发生的多个条件必须同时具备，事件才能发生，则称这种因果关系为与逻辑。在逻辑代数中，与逻辑关系用与运算描述。与运算又称为逻辑乘（Logic Multiplication），其运算符号为“·”，有时也用“∧”表示。两变量与运算关系可表示为：

$$ F = A \cdot B \quad \text{或者} \quad F = A \land B $$

#### 3. 非运算

在逻辑问题中，如果某一事件的发生取决于条件的否定，即事件与事件发生的条件之间构成矛盾，则称这种因果关系为非逻辑。在逻辑代数中，非逻辑用非运算描述。非运算也称求反运算或者逻辑否定（Logic Negation）。其运算符号为“−”，有时也用“¬”表示。非运算的逻辑关系可表示为：

$$ F = \overline{A} \quad \text{或者} \quad F = \neg A $$


### 2.2.2 复合逻辑关系

#### 1. 与非逻辑

与非逻辑是由与、非两个逻辑复合形成的，可用逻辑函数表示为：

$$ F = \overline{A \cdot B \cdot C \cdots} $$

其逻辑功能：只要变量 $A$、$B$、$C\cdots$ 中有一个为 0，则函数 $F$ 为 1；仅当变量 $A$、$B$、$C\cdots$ 全部为 1 时，函数 $F$ 为 0。

实现与非逻辑的逻辑门称为**与非门**。

#### 2. 或非逻辑

或非逻辑是由或、非两个逻辑复合形成的，可用逻辑函数表示为：

$$ F = \overline{A + B + C + \cdots} $$

其逻辑功能：只要变量 $A$、$B$、$C\cdots$ 中有一个为 1，则函数 $F$ 为 0；仅当变量 $A$、$B$、$C\cdots$ 全部为 0 时，函数 $F$ 为 1。

实现或非逻辑的逻辑门称为**或非门**。

#### 3. 与或非逻辑

与或非逻辑是由 3 种基本逻辑复合形成的，其逻辑函数表达式的形式为：

$$ F = \overline{A \cdot B + C \cdot D + \cdots} $$

其逻辑功能：仅当每一个与项均为 0 时，才能使 $F$ 为 1，否则 $F$ 为 0。

实现与或非逻辑的逻辑门称为**与或非门**。

#### 4. 异或逻辑

异或逻辑是一个二变量逻辑关系，可用逻辑函数表示为：

$$ F = A \oplus B = \overline{A} \cdot B + A \cdot \overline{B} $$

其中，“$\oplus$”是异或运算的运算符。

异或逻辑的功能：变量 $A$、$B$ 取值相同，则 $F$ 为 0；变量 $A$、$B$ 取值相异，则 $F$ 为 1。

实现异或逻辑的逻辑门称为**异或门**。

异或逻辑具有以下特性：

- **特性 1**：$A \oplus 0 = A$，$A \oplus 1 = \overline{A}$。
- **特性 2**：$A \oplus A = 0$，$A \oplus \overline{A} = 1$。
- **特性 3**：在进行异或运算的多个变量中，若有奇数个变量的值为 1，则运算结果为 1；若有偶数个变量的值为 1，则运算结果为 0。
- **特性 4**：若 $A \oplus B = C$，则 $A \oplus C = B$，$B \oplus C = A$。
- **特性 5**：$A \oplus B = B \oplus A$。
- **特性 6**：$A \oplus B \oplus C = A \oplus (B \oplus C)$。
- **特性 7**：$A \cdot (B \oplus C) = (A \cdot B) \oplus (A \cdot C)$。
- **特性 8**：
  $$
  \overline{A \oplus B \oplus C} = A \oplus \overline{B} \oplus C = \overline{A \oplus B} \oplus C = A \oplus B \oplus \overline{C}
  $$

当多个变量进行异或运算时，可用两两运算的结果再运算，也可两两依次运算。例如：

$$
F = A \oplus B \oplus C \oplus D = (A \oplus B) \oplus (C \oplus D) = ((A \oplus B) \oplus C) \oplus D
$$

#### 5. 同或逻辑

同或逻辑也是一个二变量逻辑关系，其逻辑函数表达式为：

$$
F = A \odot B = AB + \overline{A}\,\overline{B}
$$

其中，“$\odot$”为同或运算的运算符。

同或逻辑的功能：当变量 $A$、$B$ 取值相同时，则 $F$ 为 1；当变量 $A$、$B$ 取值不同时，则 $F$ 为 0。

实现同或逻辑的逻辑门称为**同或门**。

当多个变量进行同或运算时，若有奇数个变量的值为 0，则运算结果为 0；反之，若有偶数个变量的值为 0，则运算结果为 1。

### 2.2.3 逻辑运算的逻辑符号及优先级别
常用逻辑运算的逻辑符号对照表如下表所示

![s3](/note/media/s3.png)

逻辑运算的顺序如下：
（1）在三种基本逻辑运算中，非运算优先级别最高，次之是与运算，或运算优先级最低。
（2）在一般情况下，优先级别最高的是括号和长非号，其次是与运算，再次异或、同或运算，优先级别最低的是或运算。

### 2.2.4 正逻辑与负逻辑

正逻辑的各种逻辑门电路与负逻辑门的各种逻辑门电路具有一定的等价规则。例如正逻辑的与门等价与负逻辑的或门。这种等价关系可以用反演规则进行说明。

## 2.3 逻辑代数的基本定理、常用公式和规则

### 2.3.1 基本定理
![s4](/note/media/s4.png)

### 2.3.2 常用公式

**公式 1**  
$$ A + A \cdot B = A \quad , \quad A \cdot (A + B) = A $$

**公式 2**  
$$ A + \overline{A} \cdot B = A + B \quad , \quad A \cdot (\overline{A} + B) = A \cdot B $$

**公式 3**  
$$ A \cdot B + A \cdot \overline{B} = A \quad , \quad (A + B) \cdot (A + \overline{B}) = A $$

**公式 4**  
$$
A \cdot B + \overline{A} \cdot C + B \cdot C = A \cdot B + \overline{A} \cdot C \quad ,
$$
$$
(A + B) \cdot (\overline{A} + C) \cdot (B + C) = (A + B) \cdot (\overline{A} + C)
$$

**公式 5**  
$$ A + \overline{A + B} = A + \overline{B} \quad , \quad A \cdot \overline{A \cdot B} = A \cdot \overline{B} $$


### 2.3.3 重要规则

逻辑代数有 3 条重要规则：**代入规则**、**反演规则**和**对偶规则**。运用这些规则可将原有定理和公式加以扩展，从而推出一些新的运算公式。

#### 1. 代入规则

任何一个含有变量 $A$ 的逻辑等式如果将所有出现 $A$ 的位置都代之以同一个逻辑函数 $F$，则等式仍然成立。这个规则称为**代入规则**。

#### 2. 反演规则

如果将逻辑函数 $F$ 表达式中所有的 “$\cdot$” 变成 “$+$”，将 “$+$” 变成 “$\cdot$”，将 “$0$” 变成 “$1$”，将 “$1$” 变成 “$0$”，原变量变成反变量，反变量变成原变量，并保持原函数中的运算顺序不变，则所得到的新函数为原函数 $F$ 的反函数 $\overline{F}$。这一规则称为**反演规则**。

#### 3. 对偶规则

如果将逻辑函数 $F$ 表达式中所有的 “$\cdot$” 变成 “$+$”，将 “$+$” 变成 “$\cdot$”，将 “$0$” 变成 “$1$”，将 “$1$” 变成 “$0$”，并保持原函数中的运算顺序不变，则所得到的新逻辑表达式称为函数 $F$ 的**对偶式**，并记作 $F'$。

若两个逻辑函数表达式 $F(A, B, C, \cdots)$ 和 $G(A, B, C, \cdots)$ 相等，则其对偶式 $F'(A, B, C, \cdots)$ 和 $G'(A, B, C, \cdots)$ 也相等。这一规则称为**对偶规则**。


### 2.4.2 逻辑函数表达式的基本形式

#### 1. 与或表达式

与或表达式是指一个函数表达式由若干与项相或组成，其中每个与项可有一个或多个原变量或者反变量相与组成。与项有时又被称为积项，相应地，与或表达式又称为“积之和”表达式。

例如，一个四变量函数：

$$
F(A, B, C, D) = \overline{A}B + \overline{B}C + D
$$

其中，$\overline{A}B$、$\overline{B}C$ 和 $D$ 为 3 个与项，函数 $F$ 为一个与或表达式。


#### 2. 或与表达式

或与表达式是指一个函数表达式由若干或项相与构成，其中每个或项是由一个或多个原变量或者反变量相或组成。或项有时又被称为和项，相应地，或与表达式又称为“和之积”表达式。

例如，一个四变量函数：

$$
F(A, B, C, D) = (\overline{A} + B)(\overline{B} + C + D)D
$$

其中，$\overline{A} + B$、$\overline{B} + C + D$ 和 $D$ 为 3 个或项，函数 $F$ 为一个或与表达式。


#### 3. 与非表达式

由若干“与非”运算构成的表达式称为与非表达式。

由德·摩根定理 $\overline{A \cdot B} = \overline{A} + \overline{B}$ 可以看出，“与”之“非”可以产生“或”的关系。实际上，只要有了与非逻辑便可实现与、或、非 3 种基本逻辑。下面以两变量与非逻辑为例进行说明。

- **与**：  
  $$
  F = AB = \overline{\overline{AB}} = \overline{1 \cdot \overline{AB}}
  $$

- **或**：  
  $$
  F = A + B = \overline{\overline{A + B}} = \overline{\overline{A} \cdot \overline{B}} = \overline{\overline{A} \cdot 1 \cdot \overline{B} \cdot 1}
  $$

- **非**：  
  $$
  F = \overline{A} = \overline{A \cdot 1}
  $$

由于任何一种逻辑关系均可由 3 种基本逻辑通过适当的组合来实现，而与项逻辑又可实现 3 种基本逻辑。所以任何逻辑表达式都可以转为与非的形式。

采用与非逻辑可以减少逻辑电路中门的种类，提高标准化程度。

将一个混合形式的逻辑表达式变换为与非形式时，通常将表达式先变换为与或表达式，然后对该与或表达式进行两次取反，并将内层的取反根据反演规则进行取反运算，即可得到与非表达式。


#### 4. 或非表达式

由若干“或非”运算构成的表达式称为或非表达式。

同样，由德·摩根定理 $\overline{A + B} = \overline{A} \cdot \overline{B}$ 可见，“或”之“非”可以产生“与”的关系。实际上，或非逻辑也可以实现与、或、非 3 种基本逻辑。下面以两变量或非逻辑为例进行说明。

- **与**：  
  $$
  F = AB = \overline{\overline{AB}} = \overline{\overline{A} + \overline{B}} = \overline{A + 0 + B + 0}
  $$

- **或**：  
  $$
  F = A + B = \overline{\overline{A + B}} = \overline{\overline{A} + \overline{B} + 0}
  $$

- **非**：  
  $$
  F = \overline{A} = \overline{A + 0}
  $$

可见，任何逻辑表达式都可以转为或非的形式。

同样，采用或非逻辑可以减少逻辑电路中门的种类，提高标准化程度。

将一个混合形式的逻辑表达式变换为或非形式时，通常将表达式先变换为或与表达式，然后对该或与表达式进行两次取反，并将内层的取反根据反演规则进行取反运算，即可得到或非表达式。

#### 5. 与或非表达式

由若干“与或非”运算构成的表达式称为与或非表达式。

显然，与或非逻辑可以实现与、或、非的功能，这就意味着可以仅用与或非门去组成实现各种功能的逻辑电路。但实际应用中这样做会不经济，所以与或非门主要用来实现与或非形式的函数。必要时可将逻辑函数表达式的形式变换成为与或非的形式，以便使用与或非门来实现其逻辑功能。

将一个混合形式的逻辑表达式变换为与或非形式时，通常将表达式先变换为或非表达式，然后对各个或非项利用反演规则进行变换，即可得到与或非表达式。


### 2.4.3 逻辑函数表达式的标准形式

#### 1. 最小项和最大项

##### （1）最小项的定义和性质

如果一个具有 $n$ 个变量的函数的与项（乘积项）包含 $n$ 个变量，每个变量都以原变量或反变量形式出现且仅出现一次，则该与项被称为**最小项**。有时又将最小项称为**标准与项**。

最小项具有如下性质：

- **性质 1**：任意一个最小项，其相应变量有且仅有一种取值使这个最小项的值为 1，这也是最小项名称的由来。并且，最小项不同，使其值为 1 的变量取值也不同。
- **性质 2**：相同变量构成的两个不同最小项相与为 0。
- **性质 3**：$n$ 个变量的全部最小项相或为 1。
- **性质 4**：$n$ 个变量构成的最小项有 $n$ 个相邻最小项。

##### （2）最大项的定义和性质

如果一个具有 $n$ 个变量的函数的或项包含 $n$ 个变量，每个变量都以原变量或反变量形式出现且仅出现一次，该或项被称为**最大项**。有时又将最大项称为**标准或项**。

最大项具有如下性质：

- **性质 1**：任意一个最大项，其相应变量有且仅有一种取值使这个最大项的值为 0。并且，最大项不同，使其值为 0 的变量取值不同。
- **性质 2**：相同变量构成的两个不同最大项相或为 1。
- **性质 3**：$n$ 个变量的全部最大项相与为 0。
- **性质 4**：$n$ 个变量构成的最大项有 $n$ 个相邻最大项。

##### （3）最小项和最大项的关系

相同变量构成的最小项 $m_i$ 和最大项 $M_i$ 之间存在互补关系，即：

$$
\overline{m_i} = M_i \quad \text{或者} \quad m_i = \overline{M_i}
$$


#### 2. 逻辑函数表达式的标准形式

逻辑函数表达式的标准形式有**标准与或表达式**和**标准或与表达式**两种。

##### （1）标准与或表达式

由若干最小项相或构成的逻辑表达式称为标准与或表达式，也称为**最小项表达式**。

包含无关条件的逻辑函数的标准与或表达式可表示为：

$$
F = \sum m_i + \sum d_j
$$

也可表示为：

$$
\begin{cases}
F = \sum m(i) \\
\text{约束方程}
\end{cases}
$$

##### （2）标准或与表达式

由若干最大项相与构成的逻辑表达式称为标准或与表达式，也称为**最大项表达式**。

包含无关条件的逻辑函数也可以用最大项之积的形式表示。这时逻辑函数的无关项也要用相应的最大项形式来表示，常用 “$D_i$” 表示。

##### （3）两种标准表达式之间的关系

任意给定一个 $n$ 变量的逻辑函数 $F$，则它可以被表示成某个最小项之和的标准形式，即：

$$
F = \sum_{i} m_i \quad , \quad i \in (0 \sim 2^n - 1)
$$

根据 $m_i = \overline{M_i}$ 和德·摩根定理，可得：

$$
F = \sum_{i} m_i = \sum_{i} \overline{M_i} = \overline{ \prod_{i} M_i^n } = \prod_{j \ne i} M_j^n \quad , \quad i \in (0 \sim 2^n - 1),\ j \in (0 \sim 2^n - 1)
$$

其中，$j$ 是 $0 \sim 2^n - 1$ 范围内除了最小项编号以外的最大项编号。

### 2.4.4 逻辑函数表达式转换为标准表达式

#### 1. 代数转换法

#### 2. 真值表转换法

## 2.5 逻辑函数化简

### 2.5.1 代数化简法

#### 1. 最简与或表达式

最简与或表达式是指在不改变逻辑函数真值表的情况下，对逻辑函数进行变换，将其变换为与或表达式，使得表达式中的与项项数最少，且每个与项中的变量个数最少的表达式。

满足上述条件可以使相应逻辑电路中所需门的数量、门的输入端个数及相互连线均为最少，从而使电路最经济。

常用的方法可以归纳如下：

##### （1）并项法

利用公式 $ AB + A\overline{B} = A $，将两个与项合并为一项，消去一个与项，同时消去一个变量。

##### （2）吸收法

利用公式 $ A + AB = A $，吸收多余的与项，消去一个与项，同时消去一个变量。

##### （3）消去法

利用公式 $ A + \overline{A}B = A + B $，消去多余因子。

##### （4）配项法

利用 $ A \cdot 1 = A $ 及 $ A + \overline{A} = 1 $，先从函数式中适当选择某些与项，并配上其所缺的一个合适变量，然后利用并项、吸收和消去等方法进行化简。

#### 2. 最简或与表达式

用代数化简法化简或与白哦大事可直接利用定理、常用公式中的或与形式，并综合运用前面的各种方法化简。

#### 3. 其他类型逻辑表达式的化简

##### （1）最简与非表达式

用“求反加非”和反演规则可以将最简与或表达式变换为最简与非表达式。

##### （2）最简或非表达式

用“求反加非”和反演规则可以将最简或与表达式变换为最简或非表达式。

##### （3）最简与或非表达式

在最简或与表达式的基础上，两次取反，并根据反演规则去掉内层非号，即可得到最简与或非式。

### 2.5.2 卡诺图化简法
