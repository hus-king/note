# 算法分析与设计

# 一、算法基本概念

## 1.1 什么是算法

算法是为解决特定问题而设计的、**有限**、**确定**、**可行**的操作序列，具有以下五个性质：

- **输入**：零个或多个输入；  
- **输出**：至少一个输出；  
- **确定性**：每步操作无歧义；  
- **有穷性**：执行步骤有限（注意：≠“终止性”，可能无限循环但步骤定义有限）；  
- **可行性**：每步均可在有限时间内完成（即“能行性”）。

---

## 1.2 算法基本要素

- **数据对象的运算与操作**：如算术、逻辑、比较、赋值等；  
- **控制结构**：
  - 顺序结构  
  - 选择结构（`if–else`）  
  - 循环结构（`while` / `for`）  
- **数据的存储结构**：如数组、链表、树等，直接影响实现效率；  
- **问题规模 $n$**：输入大小的度量，用于复杂度分析。

---

## 1.3 效率

通常用**时间复杂度**与**空间复杂度**衡量，关注最坏/平均情形下的渐进行为：

- **时间复杂度**：基本操作执行次数关于 $n$ 的函数，记为 $T(n) = O(f(n))$；  
- **空间复杂度**：额外存储空间关于 $n$ 的增长阶，记为 $S(n) = O(g(n))$。

---

## 1.4 循环不变式（Loop Invariant）

> ✅ 注意：是“**不变式**”，不是“不等式”

**定义**：在循环**每次迭代开始前**恒成立的条件（谓词）$I$，用于严格证明循环正确性。

三要素验证：
1. **初始化**：第一次迭代前 $I$ 成立；  
2. **保持性**：若第 $k$ 次迭代前 $I$ 成立，且循环继续，则第 $k+1$ 次迭代前 $I$ 仍成立；  
3. **终止性**：循环结束后，$I$ + 终止条件 ⇒ 算法正确。

**例子**（插入排序）：  
> 在第 $j$ 轮循环开始前，子数组 $A[1..j-1]$ 是原数组前 $j-1$ 个元素的**已排序版本**。  


---

# 二、函数增长

## 2.1 上界函数：$O$ 记号

$f(n) = O(g(n))$ 当且仅当  
$$
\exists\, c > 0,\; n_0 > 0,\; \forall n \ge n_0:\; 0 \le f(n) \le c \cdot g(n)
$$  
→ 表示 $f(n)$ 的增长**不超过** $g(n)$ 的常数倍（**渐近上界**）。

> ✅ 例：$3n^2 + 2n + 1 = O(n^2)$，因 $\forall n \ge 1$，有 $3n^2 + 2n + 1 \le 6n^2$。

---

## 2.2 下界函数：$\Omega$ 记号

$f(n) = \Omega(g(n))$ 当且仅当  
$$
\exists\, c > 0,\; n_0 > 0,\; \forall n \ge n_0:\; 0 \le c \cdot g(n) \le f(n)
$$  
→ 表示 $f(n)$ 的增长**不低于** $g(n)$ 的常数倍（**渐近下界**）。

> ✅ 例：$3n^2 + 2n + 1 = \Omega(n^2)$，因 $\forall n \ge 1$，有 $3n^2 \le 3n^2 + 2n + 1$。

---

## 2.3 渐进紧确界函数：$\Theta$ 记号

$f(n) = \Theta(g(n))$ 当且仅当  
$$
f(n) = O(g(n)) \quad\text{且}\quad f(n) = \Omega(g(n))
$$  
等价于：  
$$
\exists\, c_1, c_2 > 0,\; n_0 > 0,\; \forall n \ge n_0:\; 0 \le c_1 g(n) \le f(n) \le c_2 g(n)
$$  
→ 表示 $f(n)$ 与 $g(n)$ **同阶增长**（**紧确界**）。

> ✅ 例：$3n^2 + 2n + 1 = \Theta(n^2)$。

---

## 2.4 时间复杂度

衡量算法**基本操作执行次数**随输入规模 $n$ 的增长趋势，常用最坏/平均情形：

| 类型 | 表示 | 含义 |
|------|------|------|
| 最好情况 | $\Omega$ | 理想输入下的下界 |
| 最坏情况 | $O$ | 最不利输入下的上界（最常用） |
| 平均情况 | $O$/ $\Theta$ | 随机输入下的期望增长 |
| 紧确界 | $\Theta$ | 上下界一致时使用 |

> 🔔 实际分析中，通常直接写 $T(n) = O(f(n))$ 指**最坏时间复杂度**。

常见时间复杂度阶（由低到高）：  
$$
O(1) \;<\; O(\log n) \;<\; O(n) \;<\; O(n \log n) \;<\; O(n^2) \;<\; O(2^n) \;<\; O(n!)
$$

喵～主人～第三章「分治法」来啦！简洁精准，LaTeX 公式全对齐，重点突出不啰嗦～（蹲坐端正，尾巴圈住爪子）喵～

---

# 三、分治法

## 3.1 基本步骤：分解、解决、合并

分治法三步走：

1. **分解（Divide）**：将原问题划分为 $a$ 个**规模为 $n/b$** 的子问题（通常 $a \ge 1, b > 1$）；  
2. **解决（Conquer）**：递归求解子问题；若子问题足够小（如 $n \le n_0$），直接求解；  
3. **合并（Combine）**：将子问题的解合并为原问题的解。

> ✅ 典型结构：
> ```text
> if 问题规模小 → 直接解  
> else → 分解 → 递归求解 → 合并
> ```

---

## 3.2 与递归的关系

- 分治法**通常用递归实现**，但**递归 ≠ 分治**；  
- 分治强调：**子问题相互独立 + 合并步骤非平凡**；  
- 递归是实现手段，分治是设计思想（策略层）。

> ❗ 反例：链表遍历用递归，但无“合并”，不算分治。

---

## 3.3 非空连续子数组（最大子数组问题）

**问题**：给定数组 $A[1..n]$，求非空连续子数组 $A[i..j]$ 使得 $\sum_{k=i}^j A[k]$ 最大。

**分治解法**：  
- 中点 $m = \lfloor n/2 \rfloor$；  
- 最大子数组要么：
  - 完全在左半：$A[1..m]$  
  - 完全在右半：$A[m+1..n]$  
  - 跨越中点：必含 $A[m], A[m+1]$，可 $O(n)$ 线性扫描求跨中点最大和  
- 递归式：  
  $$
  T(n) = 2T(n/2) + O(n) \;\Rightarrow\; T(n) = O(n \log n)
  $$

（Kadane 算法为 $O(n)$ 动态规划解法，非分治）

---

## 3.4 Strassen 矩阵乘法

**目标**：降低 $n \times n$ 矩阵乘法的复杂度（传统为 $\Theta(n^3)$）。

**核心思想**：  
- 将 $A, B$ 分块为 $4$ 个 $\frac{n}{2} \times \frac{n}{2}$ 子矩阵；  
- 不用 8 次递归乘法，而用 **7 次巧妙组合的乘法 + 18 次加减**；  
- 递归式：  
  $$
  T(n) = 7T(n/2) + O(n^2) \;\overset{\text{主定理}}{\Rightarrow}\; T(n) = \Theta(n^{\log_2 7}) \approx \Theta(n^{2.81})
  $$

> 💡 实际中因常数大，仅对超大规模矩阵有优势～喵～

---

## 3.5 最近点对

**问题**：平面上 $n$ 个点，找欧氏距离最小的一对。

**分治步骤**：
1. 按 $x$ 坐标排序，中线 $x = m$ 分左右集合 $L, R$；  
2. 递归求 $L, R$ 中最近距离 $d_L, d_R$，令 $\delta = \min(d_L, d_R)$；  
3. **关键合并**：仅需检查中线两侧宽度为 $\delta$ 的带状区域内点对；  
   - 可证：每个点只需与**至多 6 个**后续点比较（按 $y$ 排序后线性扫描）；  
4. 递归式：  
   $$
   T(n) = 2T(n/2) + O(n) \;\Rightarrow\; T(n) = O(n \log n)
   $$

> 🌟 预排序 $O(n \log n)$ 仅需一次，后续递归用副本或索引避免重复排序。

---

## 3.6 求解递归式

### （1）代换法（Substitution）
- **猜解** + **数学归纳法证明**；  
- 适用于能猜出形式的情况（如 $T(n) = 2T(n/2) + n \overset{?}{=} O(n \log n)$）。

### （2）递归树法（Recursion Tree）
- 将递归展开为树，每层计算代价，求和得总代价；  
- 直观，适合推导“猜解”或处理非标准形式。

### （3）主定理（Master Theorem）  
对形如  
$$
T(n) = a\,T\!\left(\frac{n}{b}\right) + f(n), \quad a \ge 1,\; b > 1
$$  
设 $n^{\log_b a}$ 为**临界函数**，比较 $f(n)$ 与之大小：

| 情形 | 条件 | 解 |
|------|------|----|
| 1 | $f(n) = O(n^{\log_b a - \varepsilon})$, $\varepsilon > 0$ | $T(n) = \Theta(n^{\log_b a})$ |
| 2 | $f(n) = \Theta(n^{\log_b a} \log^k n)$, $k \ge 0$ | $T(n) = \Theta(n^{\log_b a} \log^{k+1} n)$ |
| 3 | $f(n) = \Omega(n^{\log_b a + \varepsilon})$, $\varepsilon > 0$，且 $a f(n/b) \le c f(n)$（正则条件） | $T(n) = \Theta(f(n))$ |

> ✅ 例：Strassen 中 $a=7, b=2, f(n)=n^2$，$\log_2 7 \approx 2.81 > 2$ ⇒ 情形 1 ⇒ $\Theta(n^{\log_2 7})$。

喵～主人～第四章「动态规划」已火速整理完毕！简洁、准确、公式规范，重点全标粗～（端坐甩尾，爪垫轻轻敲键盘）喵～

---

# 四、动态规划

## 4.1 最优子结构、无后效性、递归表达式

- **最优子结构**：问题最优解包含其子问题的最优解；  
  → 是应用 DP 的**前提**（反例：最长简单路径问题无此性质）。

- **无后效性（无后向性）**：某阶段状态一旦确定，此后过程**不受此前路径影响**；  
  → 保证状态可压缩为仅与当前有关的变量（如 $dp[i]$ 仅依赖 $dp[j], j < i$）。

- **递归表达式（状态转移方程）**：  
  描述当前状态与更小子问题解的关系，是 DP 的核心设计；  
  一般形式：  
  $$
  dp[i] = \min_{k \in \text{choices}} \{ \text{cost}(k) + dp[\text{next}(i,k)] \}
  $$  
  （或 $\max$，视问题而定）

> ✅ 三要素齐全 ⇒ 可用 DP：**定义状态 → 推转移方程 → 确定边界/顺序**

---

## 4.2 证明方法：剪切-粘贴（Cut-and-Paste）

用于**验证最优子结构**是否成立：

1. **假设**：原问题最优解 $S$ 中含子问题解 $S'$；  
2. **剪切**：若 $S'$ 不是最优的，存在更优子解 $S''$；  
3. **粘贴**：将 $S'$ 替换为 $S''$，得到新解 $S^*$；  
4. **矛盾**：若 $S^*$ 比 $S$ 更优 ⇒ 与 $S$ 最优矛盾 ⇒ 故 $S'$ 必为最优。

> ✅ 本质：**反证法**，强调“局部最优可替换为全局更优” ⇒ 局部必须最优。

---

## 4.3 钢条切割

**问题**：长度为 $n$ 的钢条，价格表 $p[1..n]$，求切割方案使总价最大。

- **状态**：$r[i]$ 表示长度为 $i$ 的钢条最大收益；  
- **转移**：  
  $$
  r[i] = \max_{1 \le j \le i} \{ p[j] + r[i-j] \}, \quad r[0] = 0
  $$
- **复杂度**：$O(n^2)$ 时间，$O(n)$ 空间（可优化为一维）；  
- **可记录方案**：另存 $s[i]$ 为第一段长度。

---

## 4.4 矩阵链乘法

**问题**：矩阵链 $\langle A_1, A_2, \dots, A_n \rangle$，维度 $p_0 \times p_1, p_1 \times p_2, \dots, p_{n-1} \times p_n$，求加括号方式使标量乘法次数最少。

- **状态**：$m[i,j]$ 表示计算 $A_i \cdots A_j$ 的最小代价；  
- **转移**：  
  $$
  m[i,j] = 
  \begin{cases}
    0 & i = j \\
    \min_{i \le k < j} \{ m[i,k] + m[k+1,j] + p_{i-1} p_k p_j \} & i < j
  \end{cases}
  $$
- **计算顺序**：按子链长度 $l = j-i+1$ 递增；  
- **复杂度**：$O(n^3)$ 时间，$O(n^2)$ 空间。

![sf1](/media/sf1.png)

---

## 4.5 最长公共子序列（LCS）

**问题**：给定 $X[1..m], Y[1..n]$，求最长公共**子序列**（不要求连续）。

- **状态**：$c[i,j]$ 表示 $X[1..i]$ 与 $Y[1..j]$ 的 LCS 长度；  
- **转移**：  
  $$
  c[i,j] =
  \begin{cases}
    0 & i=0 \text{ 或 } j=0 \\
    c[i-1,j-1] + 1 & X[i] = Y[j] \\
    \max\{c[i-1,j],\; c[i,j-1]\} & X[i] \ne Y[j]
  \end{cases}
  $$
- **路径回溯**：从 $c[m,n]$ 反向追踪可得一个 LCS；  
- **复杂度**：$O(mn)$ 时间与空间（可压缩至 $O(\min\{m,n\})$ 空间求长度）。

![sf2](/media/sf2.png)

---

## 4.6 最优二叉搜索树（OBST）

**问题**：给定有序关键字 $k_1 < \dots < k_n$，搜索概率 $p_i$（命中），及伪关键字 $d_0, \dots, d_n$ 概率 $q_i$（未命中），构造期望搜索代价最小的 BST。

- **状态**：$e[i,j]$ 表示包含关键字 $k_i$ 到 $k_j$ 的子树的最小期望搜索代价；  
- **辅助**：$w[i,j] = \sum_{l=i}^j p_l + \sum_{l=i-1}^j q_l$（子树总概率）；  
- **转移**：  
  $$
  e[i,j] = 
  \begin{cases}
    q_{i-1} & i = j + 1\\
    \min_{r=i}^j \{ e[i,r-1] + e[r+1,j] + w[i,j] \} & i \le j
  \end{cases}
  $$
- **记录结果**：$root[i,j]$ 用于记录所有最优二叉搜索子树的根结点

![sf3](/media/sf3.png)

> 🌟 注：$w[i,j]$ 满足 $w[i,j] = w[i,j-1] + p_j + q_j$，可预处理加速。

---

# 五、贪心方法

## 5.1 与动态规划的区别

| 特性 | 贪心算法 | 动态规划 |
|------|----------|----------|
| **选择时机** | **每步局部最优 + 立即决定**，不回退 | 先保存所有子问题解，最后选全局最优 |
| **子问题重叠** | 通常**无重叠**（顺序决策） | **有重叠**，需记忆化/填表 |
| **最优子结构** | 需满足 **贪心选择性质**（局部最优 ⇒ 全局最优） | 仅需最优子结构 |
| **效率** | 通常 $O(n \log n)$ 或 $O(n)$（排序+扫描） | 多为 $O(n^2)$ 或更高 |
| **正确性** | 需**额外证明**（非所有问题适用） | 正确性由状态转移保障 |

> ✅ **核心差异**：贪心是“**只向前看，永不后悔**”；DP 是“**把所有可能性记下来再挑最好的**”。

---

## 5.2 证明最优：归纳法 + 反证法（交换论证）

常用 **交换论证（Exchange Argument）**：

1. **设** $A = \langle a_1, a_2, \dots, a_k \rangle$ 是贪心解，  
   $O = \langle o_1, o_2, \dots, o_m \rangle$ 是某最优解；  
2. 若 $A \ne O$，找**第一个分歧点** $i$（即 $a_j = o_j$ for $j < i$, 但 $a_i \ne o_i$）；  
3. **构造**新解 $O'$：将 $O$ 中 $o_i$ 换成 $a_i$，并调整后续保持可行性；  
4. 证 $O'$ 仍最优（代价不增）；  
5. 重复 ⇒ 可将任意最优解“贪心化”，故贪心解最优。

> 🌟 本质：**归纳地将最优解“变形”为贪心解，代价不升** ⇒ 贪心解必最优。

---

## 5.3 活动选择问题

**问题**：$n$ 个活动 $\{a_i = [s_i, f_i)\}$，选**最多互不重叠**活动。

- **贪心策略**：**按结束时间 $f_i$ 升序排序**，每次选**最早结束**的兼容活动；  
- **算法**（迭代版）：
  ```text
  A ← {a₁}   // a₁ 是 f 最小者
  k ← 1
  for i = 2 to n:
      if s_i ≥ f_k:
          A ← A ∪ {a_i}
          k ← i
  ```
- **复杂度**：$O(n \log n)$（排序主导）；  
- **正确性**：由贪心选择性质 + 最优子结构保证（第一个活动选最早结束的必在某最优解中）。

---

## 5.4 Huffman 编码

**问题**：给字符集 $\Sigma$，频率 $f(c) > 0$，构造**前缀码**使平均码长 $\sum_{c} f(c) \cdot \text{len}(c)$ 最小。

- **贪心策略**：**每次合并频率最小的两棵树**；  
- **算法**（优先队列实现）：
  1. 每字符建单节点树，插入最小堆；  
  2. 重复 $|\Sigma|-1$ 次：
     - 取出最小两棵 $x, y$；  
     - 合并为新树 $z$，$f(z) = f(x)+f(y)$；  
     - 插入 $z$；  
  3. 剩余一棵即 Huffman 树。
- **复杂度**：$O(n \log n)$；  
- **最优性证明**：  
  - 引理1：存在最优树，**频率最小两字符为兄弟叶节点**；  
  - 引理2：合并后子问题最优 ⇒ 原问题最优（归纳+交换论证）。

> 💡 编码长度满足 **Kraft 不等式** $\sum 2^{-\ell_i} \le 1$，且 Huffman 码达到 **Shannon 下界**附近。

![sf4](/media/sf4.png)

---

# 六、基本图算法

## 6.1 最小生成树（MST）

目标：连通无向带权图 $G=(V,E,w)$ 中，找权和最小的生成树。

### Kruskal 算法  
- **策略**：按边权**升序**贪心选边，**避免环**（用并查集判连通）；  
- **步骤**：
  1. $E$ 按 $w$ 排序；  
  2. 初始化森林（每点独立）；  
  3. 遍历边 $(u,v)$：若 $u,v$ 不在同一连通分量 ⇒ 加入 MST；  
- **复杂度**：$O(E \log E) = O(E \log V)$；  
- **适用**：稀疏图，边已排序时极快。

### Prim 算法  
- **策略**：从任一点出发，**每次加最轻横切边**（类似 Dijkstra）；  
- **实现**：优先队列（最小堆）维护点到当前树的距离 $\text{key}[v]$；  
- **复杂度**：
  - 二叉堆：$O(E \log V)$  
  - Fibonacci 堆：$O(E + V \log V)$  
- **适用**：稠密图、邻接矩阵存储。

> ✅ 共同前提：图连通；若不连通 → 得**最小生成森林**。

---

## 6.2 单源最短路径（SSSP）

### 核心概念  
- **松弛（Relaxation）**：  
  $$
  \text{if } d[v] > d[u] + w(u,v),\quad \text{then } d[v] \gets d[u] + w(u,v),\ \pi[v] \gets u
  $$
- **三角不等式**：对任意最短路径 $\delta(s,v) \le \delta(s,u) + w(u,v)$，松弛即尝试逼近等号。

### Bellman-Ford  
- **适用**：允许**负权边**，可检测**负环**；  
- **步骤**：对所有边松弛 $|V|-1$ 轮；第 $|V|$ 轮若仍可松弛 ⇒ 存负环；  

| 顶点 | 距离 | 前驱 |
| :---: | :---: | :---: |
| A | 0 | - |
| B | 2 | C |
| C | 4 | A |
| D | 5 | A |
| E | 5 | B |
| F | ∞ | - |
- **复杂度**：$O(VE)$；  
- **差分约束系统**：形如 $x_j - x_i \le b_k$ 的不等式组 ⇔ 图中边 $(i,j)$ 权 $b_k$，  
  ⇒ 添加超级源 $s$，$x_i = \delta(s,i)$ 即一组可行解（若无负环）。

### Dijkstra  
- **适用**：**非负权边**（$w(u,v) \ge 0$）；  
- **策略**：贪心选当前 $d[u]$ 最小的未定节点（永久标号）；  
- **复杂度**：
  - 二叉堆：$O((V+E)\log V)$  
  - Fibonacci 堆：$O(V \log V + E)$  
- **注意**：负权边会导致错误（已定节点可能被更短路径更新）。

---

## 6.3 每对结点最短路径（APSP）

### 递归表达式（动态规划视角）
令 $d_{ij}^{(m)}$ 为 $i \to j$ 最多经 $m$ 条边的最短路径长：
$$
d_{ij}^{(m)} = \min_{1 \le k \le n} \left\{ d_{ik}^{(m-1)} + w_{kj} \right\}
\quad\Rightarrow\quad
\mathbf{D}^{(m)} = \mathbf{D}^{(m-1)} \otimes \mathbf{W}
$$
其中 $\otimes$ 为 **min-plus 矩阵乘**（$(A \otimes B)_{ij} = \min_k \{A_{ik} + B_{kj}\}$）。

![sf5](/media/sf5.png)

### Floyd-Warshall  
- **状态**：$d_{ij}^{(k)}$ = $i \to j$ 路径上**中间点编号 ≤ $k$** 的最短距离；  
- **转移**：  
  $$
  d_{ij}^{(k)} = \min\left( d_{ij}^{(k-1)},\ d_{ik}^{(k-1)} + d_{kj}^{(k-1)} \right)
  $$
- **初始化**：$d_{ij}^{(0)} = 
  \begin{cases}
    0 & i=j \\
    w_{ij} & (i,j) \in E \\
    \infty & \text{otherwise}
  \end{cases}$  
- **复杂度**：$O(V^3)$，空间 $O(V^2)$；  
- **额外功能**：  
  - 检测负环：若存在 $d_{ii}^{(n)} < 0$；  
  - 传递闭包：令 $w_{ij}=1$（若边存在），用 $(\lor, \land)$ 代替 $(\min, +)$。
![sf6](/media/sf6.png)

### 图的连通性  
- **无向图**：Floyd 后 $d_{ij} < \infty$ ⇔ 连通；  
- **有向图**：  
  - 强连通 ⇔ $\forall i,j,\ d_{ij} < \infty$ 且 $d_{ji} < \infty$；  
  - 可用 **Kosaraju / Tarjan** 更高效（$O(V+E)$）。

---

## 6.4 Johnson 算法

**目标**：稀疏图上高效求 APSP，**支持负权边（但无负环）**。

**思想**：重赋权 → 所有边非负 → 对每个点跑 Dijkstra。

**步骤**：
1. 添加新源点 $s$，连向所有 $v \in V$，边权 0；  
2. 用 Bellman-Ford 算 $\hat{h}(v) = \delta(s,v)$；  
3. **重赋权**：  
   $$
   \hat{w}(u,v) = w(u,v) + \hat{h}(u) - \hat{h}(v)
   $$
   ⇒ 保证 $\hat{w}(u,v) \ge 0$，且路径相对长短不变；  
4. 对每个 $u \in V$，在 $\hat{G}$ 上运行 Dijkstra 得 $\hat{d}(u,v)$；  
5. 还原真实距离：  
   $$
   d(u,v) = \hat{d}(u,v) - \hat{h}(u) + \hat{h}(v)
   $$

**复杂度**:

$$
O(VE) \text{（Bellman-Ford）} + O(V \cdot (V \log V + E)) \text{（Dijkstra × V）}
= \begin{cases}
O(VE \log V) & \text{二叉堆} \\
O(V^2 \log V + VE) & \text{Fib 堆}
\end{cases}
$$

→ 对稀疏图（$E \ll V^2$）优于 Floyd 的 $O(V^3)$。

---

# 七、最大流

## 7.1 问题定义

给定**流网络** $G = (V, E)$：  
- 有向图，源点 $s$、汇点 $t$；  
- 容量函数 $c: E \to \mathbb{R}_{\ge 0}$；  
- 流函数 $f: V \times V \to \mathbb{R}$ 满足：  
  1. **容量限制**：$\forall u,v,\ 0 \le f(u,v) \le c(u,v)$；  
  2. **反对称性**：$f(u,v) = -f(v,u)$；  
  3. **流守恒**：$\forall u \in V \setminus \{s,t\},\ \sum_{v \in V} f(u,v) = 0$。  

**目标**：最大化**从 $s$ 到 $t$ 的净流量**  
$$
|f| = \sum_{v \in V} f(s,v)
$$

---

## 7.2 残存网络（Residual Network）

给定流 $f$，定义**残存容量**：  
$$
c_f(u,v) = 
\begin{cases}
c(u,v) - f(u,v) & \text{若 } (u,v) \in E \\
f(v,u) & \text{若 } (v,u) \in E \\
0 & \text{否则}
\end{cases}
$$  
→ 允许**反向边**表示“撤销流量”。

**残存网络** $G_f = (V, E_f)$，其中  
$$
E_f = \{ (u,v) \mid c_f(u,v) > 0 \}
$$  
**增广路径**：$G_f$ 中从 $s$ 到 $t$ 的路径 $p$；  
**可增流量**：$c_f(p) = \min_{(u,v) \in p} c_f(u,v)$；  
→ 沿 $p$ 增广：$f \gets f + f_p$（$f_p$ 为路径流）。

> ✅ **Ford-Fulkerson 方法**：反复找增广路，直到 $G_f$ 中无 $s \to t$ 路径。

![sf7](/media/sf7.png)

---

## 7.3 最小割（Min-Cut）

**割**：顶点划分 $(S, T)$ 满足 $s \in S,\ t \in T$；  
**割容量**：  
$$
c(S,T) = \sum_{u \in S,\, v \in T} c(u,v)
$$  
（仅算**正向边**，不含 $T \to S$）

**最大流最小割定理**：  
$$
\max_f |f| \;=\; \min_{(S,T)} c(S,T)
$$  
→ 当 Ford-Fulkerson 终止时，令 $S = \{v \mid \exists\, s \to v \text{ 路径 in } G_f\}$，则 $(S, V \setminus S)$ 为最小割。

> 💡 推论：最大流值 = 最小割容量；整数容量 ⇒ 存整数最大流。

---

## 7.4 最优二分匹配（最大基数匹配 / 最大权匹配）

### （1）最大基数二分匹配  
- **建模**：二分图 $G = (X \cup Y, E)$ → 构造流网络：  
  - 加源 $s$ 连 $X$（容量 1），$Y$ 连汇 $t$（容量 1），原边 $X \to Y$（容量 1）；  
- **最大匹配大小** = **最大流值**；  
- **算法**：Dinic 在单位容量二分图上 $O(\sqrt{V}E)$（Hopcroft-Karp 思想）。

### （2）最大权完美匹配（Assignment Problem）  
- **输入**：完全二分图，边权 $w_{ij}$；  
- **建模**：转化为**最小费用流**：  
  - 源 $s \to X_i$（容量 1, 费用 0）；  
  - $X_i \to Y_j$（容量 1, 费用 $-w_{ij}$）；  
  - $Y_j \to t$（容量 1, 费用 0）；  
  - 求 $|X|$ 单位流的**最小费用流** ⇒ 负费用和即最大权；  
- **专用算法**：**Hungarian 算法**，$O(n^3)$。

> 🌟 小知识：稳定婚姻问题 ≠ 最大流，需 Gale-Shapley 算法～喵～

---

# 八、图树周游

## 8.1 宽度优先搜索（BFS）

- **策略**：从源点 $s$ 出发，**逐层扩展**，用**队列**实现 FIFO；  
- **核心数据**：
  - `color[v]`：WHITE（未发现）、GRAY（已发现未完成）、BLACK（已完成）  
  - `d[v]`：$s$ 到 $v$ 的最短路径边数（无权图）  
  - `π[v]`：前驱  
- **性质**：
  - 对无权图，$d[v] = \delta(s,v)$（最短路径距离）；  
  - BFS 树中每条边 $(u,v)$ 满足 $|d[u] - d[v]| \le 1$；  
- **复杂度**：$O(V + E)$；  
- **应用**：最短路径（无权）、连通分量、二分图判定（染色法）。

---

## 8.2 深度优先搜索（DFS）

- **策略**：尽可能深探，回溯时完成节点，用**栈**（递归隐式实现）；  
- **核心数据**：
  - `color[v]`：同上；  
  - `d[v]`：发现时间（DFS 开始访问 $v$ 的时刻）；  
  - `f[v]`：完成时间（DFS 回溯离开 $v$ 的时刻）；  
  - `π[v]`：前驱  
- **边分类**（对有向图）：
  - **树边**（Tree）：DFS 树中的边；  
  - **前向边**（Forward）：$u \to v$，$v$ 是 $u$ 的后代；  
  - **后向边**（Back）：$u \to v$，$v$ 是 $u$ 的祖先 ⇒ **存在环**；  
  - **横跨边**（Cross）：无祖先后代关系；  
- **括号定理**：对任意两节点 $u,v$，区间 $[d[u],f[u]]$ 与 $[d[v],f[v]]$ 要么不交，要么一者包含另一者；  
- **复杂度**：$O(V + E)$；  
- **应用**：拓扑排序、强连通分量（SCC）、环检测。

---

## 8.3 生成树、判断图的连通性

### 生成树（Spanning Tree）
- BFS/DFS 在**连通无向图**上遍历时访问的边构成一棵**生成树**；  
- 若图不连通 ⇒ 得**生成森林**（每棵树对应一个连通分量）；  
- BFS 树称**最短路径树**（无权意义下）；DFS 树称**深度优先生成树**。

### 判断连通性
- **无向图**：
  - 从任一点 BFS/DFS，若访问节点数 $= |V|$ ⇒ 连通；  
  - 否则，访问集合即一个连通分量；  
- **有向图**：
  - **弱连通**：忽略方向后连通；  
  - **强连通**：$\forall u,v$，存在 $u \leadsto v$ 且 $v \leadsto u$；  
    → 可用 **Kosaraju** 或 **Tarjan**（基于 DFS 完成时间/栈）求 SCC；  
    → 若仅一个 SCC ⇒ 强连通。

> ✅ 小技巧：BFS 判二分图 ⇔ 无奇环；DFS 遇后向边 ⇔ 有环。
---

# 九、回溯法

## 9.1 状态空间

- **定义**：问题所有可能解构成的**隐式树结构**（解空间树）；  
- 每个节点代表一个**部分解**（决策前缀）；  
- 根 → 叶路径对应一个**完整候选解**；  
- 回溯 = **深度优先遍历解空间树 + 剪枝**。

> ✅ 状态空间可为：  
> - 排列树（如 TSP，$n!$ 叶）  
> - 子集树（如 0-1 背包，$2^n$ 叶）  
> - 满 $m$ 叉树（如 $n$ 皇后，$n^n$ 叶）

---

## 9.2 显式约束、隐式约束、限界函数

| 类型 | 含义 | 作用 |
|------|------|------|
| **显式约束** | 对单个变量取值的直接限制（如 $x_i \in \{0,1\}$） | 限定**解空间范围** |
| **隐式约束** | 变量间的逻辑/全局约束（如 $\sum w_i x_i \le C$） | 用于**剪枝**：一旦部分解违反 ⇒ 全部子树剪掉 |
| **限界函数（Bound Function）** | 估算当前部分解扩展后**可能达到的最优值上/下界** | 用于**剪枝**：若界已劣于当前最优解 ⇒ 剪枝（常用于**回溯 + 分支限界**） |

> 💡 回溯核心：**约束满足问题（CSP）** → 用隐式约束剪枝；  
> 分支限界：**优化问题** → 用限界函数剪枝。

---

## 9.3 求解树的构造

1. **定义解向量**：$X = (x_1, x_2, \dots, x_n)$；  
2. **确定决策顺序**：通常从 $x_1$ 到 $x_n$ 依次赋值；  
3. **递归框架**：
   ```python
   def backtrack(k):   # 决策第 k 个分量
       if k > n: 
           output(X)   # 得到一个可行解
           return
       for x_k in choices(k):
           X[k] = x_k
           if feasible(X[1..k]):      # 隐式约束检查（剪枝）
               backtrack(k+1)
   ```
4. **剪枝时机**：在扩展子节点前检查约束，避免无效递归。

---

## 9.4 N-皇后问题

**问题**：在 $n \times n$ 棋盘放 $n$ 皇后，互不攻击（不同行、列、对角线）。

- **解表示**：$X = (x_1, x_2, \dots, x_n)$，$x_i$ = 第 $i$ 行皇后列号；  
- **显式约束**：$x_i \in \{1,2,\dots,n\}$；  
- **隐式约束**（对 $i < j$）：
  - 列冲突：$x_i \ne x_j$  
  - 主对角线：$x_i - i \ne x_j - j$  
  - 副对角线：$x_i + i \ne x_j + j$  
- **剪枝实现**：用三集合维护已占列/主对角/副对角：
  ```python
  col, diag1, diag2 = set(), set(), set()
  # diag1: i - x_i; diag2: i + x_i
  ```
- **复杂度**：最坏 $O(n!)$，但剪枝后实际远小于此（$n=8$ 仅探索 2057 个节点）。

![sf8](/media/sf8.png)

---

## 9.5 子集和数问题（Subset Sum）

**问题**：给定正整数集 $S = \{w_1,\dots,w_n\}$ 与目标 $M$，找子集 $S' \subseteq S$ 使 $\sum_{w \in S'} w = M$。

- **解表示**：$X = (x_1,\dots,x_n),\ x_i \in \{0,1\}$；  
- **隐式约束**：
  - 已选和 $> M$ ⇒ 剪枝；  
  - 已选和 + 剩余所有 $< M$ ⇒ 剪枝；  
- **优化剪枝**（排序后）：
  - 先按 $w_i$ **降序排列**，加速超界；  
  - 维护前缀和 $sum_k = \sum_{i=1}^k w_i x_i$，后缀和 $r_k = \sum_{i=k+1}^n w_i$；  
  - 剪枝条件：
    $$
    \text{if } sum_k > M \quad\text{or}\quad sum_k + r_k < M \quad\Rightarrow\quad \text{剪枝}
    $$
- **输出**：可求所有解 / 任一解 / 判定存在性。

> 🌟 推广：0-1 背包最大价值 ⇒ 加**限界函数**（如贪心上界）即为**分支限界法**。

![sf9](/media/sf9.png)

---

# 十、分枝限界（Branch and Bound）

## 10.1 与回溯法的区别

| 特性 | 回溯法 | 分枝限界 |
|------|--------|-----------|
| **搜索策略** | 深度优先（DFS） | **广度优先（BFS）或最小耗费优先（LC）** |
| **目标** | 找**任一/所有可行解**（CSP） | 找**最优解**（优化问题） |
| **剪枝依据** | **约束违反**（隐式约束） | **限界函数**（当前界 ≥ 已知最优 ⇒ 剪枝） |
| **数据结构** | 递归栈 | **优先队列（堆）** 存活结点 |
| **空间开销** | $O(n)$（路径深度） | 可达 $O(b^d)$（$b$ 分支因子，$d$ 深度） |
| **适用问题** | N-皇后、子集和（判定） | 0-1 背包、TSP、调度（优化） |

> ✅ 核心差异：**回溯剪“不可行”，分枝限界剪“不最优”**。

---

## 10.2 LC-检索（Least Cost Search）

- **思想**：不按层扩展，而按**估计代价最小者优先**；  
- **结点代价估计**：$\hat{c}(x) = g(x) + h(x)$  
  - $g(x)$：从根到 $x$ 的实际代价（已发生）  
  - $h(x)$：$x$ 到目标的**启发式下界**（需满足 $h(x) \le h^*(x)$ 以保最优性）  
- **算法流程**：
  1. 初始化优先队列 $Q$，加入根结点；  
  2. 循环：取 $\hat{c}$ 最小结点 $x$ 出队；  
     - 若 $x$ 是答案叶 ⇒ 返回；  
     - 否则生成子结点 $y$，计算 $\hat{c}(y)$，入队；  
  3. 直至 $Q$ 空或找到最优解。  
- **与 A\* 关系**：LC-检索是 A\* 在**状态空间图**上的应用，A\* 更通用。

> 💡 若 $h(x) \equiv 0$ ⇒ 退化为**普通 BFS**；若 $h(x)$ 是完美启发 ⇒ 直达最优解。

---

## 10.3 15-谜问题（15-Puzzle）

**问题**：$4 \times 4$ 棋盘，15 个编号方块 + 1 空格，滑动至目标状态。

- **状态表示**：棋盘布局（可编码为整数或字符串）；  
- **分支**：空格上/下/左/右移（≤4 个子状态）；  
- **代价 $g(x)$**：已走步数；  
- **常用启发 $h(x)$**：
  - **曼哈顿距离**：$\sum_{i=1}^{15} (|r_i - r_i^*| + |c_i - c_i^*|)$  
    → 可接受（admissible），因每次移动最多减少 1；  
  - **错位方块数**：较弱上界，效率低；  
- **LC-检索**：用最小堆维护 $(g+h, \text{state})$；  
- **注意**：仅一半初始状态有解（逆序对奇偶性判定）。

> 🌟 实际实现需哈希判重（如用 `unordered_set` 存状态），否则重复爆炸。

![sf10](/media/sf10.png)

---

## 10.4 惩罚作业调度（Job Sequencing with Deadlines & Penalties）

**问题**：$n$ 个作业，各需 1 单位时间，截止时间 $d_i$，逾期惩罚 $w_i$；  
求调度顺序使**总惩罚最小**（等价于**准时作业总权最大**）。

- **建模为分枝限界**：
  - **解空间**：排列树（第 $k$ 层决定第 $k$ 个位置放哪个作业）；  
  - **状态**：已安排作业集合 $S$，当前时间 $t = |S|$；  
  - **$g(x)$**：已产生惩罚 $\sum_{i \in S,\, d_i < t} w_i$；  
  - **$h(x)$（下界）**：对未安排作业 $U$，贪心计算**最小可能新增惩罚**：  
    - 将 $U$ 按 $d_i$ 升序排，模拟安排（跳过超时作业），未安排者累加 $w_i$；  
    ⇒ 得 $h(x)$ 为剩余最小惩罚下界；  
  - **限界**：若 $g(x) + h(x) \geq$ 当前最优 ⇒ 剪枝。  

- **更优解法**：贪心（按 $w_i$ 降序，用并查集找最晚可行槽）可达 $O(n \log n)$，  
  但分枝限界可用于带复杂约束的变体（如不同处理时间）。

> ✅ 推广：若作业有权重 $p_i$（收益），目标为**最大加权准时作业** ⇒ 同结构，$g(x)$ 为已得收益，$h(x)$ 为剩余最大可能收益上界。

![sf11](/media/sf11.png)