# 算法分析与设计

# 第四章 分治策略

## 4.1 最大子数组问题(非空连续子数组)

```cpp
// 定义一个结构体来存放结果：最大和、起始索引、结束索引
typedef struct {
    int sum;
    int low;
    int high;
} Result;

// 辅助函数：寻找跨越中点的最大子数组
Result find_max_crossing_subarray(int A[], int low, int mid, int high) {
    int left_sum = INT_MIN; // 初始化为最小值
    int sum = 0;
    int max_left = mid;

    // 从中点向左扫描，寻找左边部分的最大和
    for (int i = mid; i >= low; i--) {
        sum += A[i];
        if (sum > left_sum) {
            left_sum = sum;
            max_left = i;
        }
    }

    int right_sum = INT_MIN;
    sum = 0;
    int max_right = mid + 1;

    // 从中点向右扫描，寻找右边部分的最大和
    for (int j = mid + 1; j <= high; j++) {
        sum += A[j];
        if (sum > right_sum) {
            right_sum = sum;
            max_right = j;
        }
    }

    // 合并左右两部分
    Result result;
    result.sum = left_sum + right_sum;
    result.low = max_left;
    result.high = max_right;
    return result;
}

// 主函数：分治法求解最大子数组
Result find_maximum_subarray(int A[], int low, int high) {
    // 基准情况：只有一个元素
    if (high == low) {
        Result result;
        result.sum = A[low];
        result.low = low;
        result.high = high;
        return result;
    } else {
        int mid = (low + high) / 2;

        // 递归求解左半部分
        Result left_result = find_maximum_subarray(A, low, mid);
        // 递归求解右半部分
        Result right_result = find_maximum_subarray(A, mid + 1, high);
        // 求解跨越中点的情况
        Result cross_result = find_max_crossing_subarray(A, low, mid, high);

        // 比较三者，返回最大值
        if (left_result.sum >= right_result.sum && left_result.sum >= cross_result.sum) {
            return left_result;
        } else if (right_result.sum >= left_result.sum && right_result.sum >= cross_result.sum) {
            return right_result;
        } else {
            return cross_result;
        }
    }
}
``````cpp
// 定义一个结构体来存放结果：最大和、起始索引、结束索引
typedef struct {
    int sum;
    int low;
    int high;
} Result;

// 辅助函数：寻找跨越中点的最大子数组
Result find_max_crossing_subarray(int A[], int low, int mid, int high) {
    int left_sum = INT_MIN; // 初始化为最小值
    int sum = 0;
    int max_left = mid;

    // 从中点向左扫描，寻找左边部分的最大和
    for (int i = mid; i >= low; i--) {
        sum += A[i];
        if (sum > left_sum) {
            left_sum = sum;
            max_left = i;
        }
    }

    int right_sum = INT_MIN;
    sum = 0;
    int max_right = mid + 1;

    // 从中点向右扫描，寻找右边部分的最大和
    for (int j = mid + 1; j <= high; j++) {
        sum += A[j];
        if (sum > right_sum) {
            right_sum = sum;
            max_right = j;
        }
    }

    // 合并左右两部分
    Result result;
    result.sum = left_sum + right_sum;
    result.low = max_left;
    result.high = max_right;
    return result;
}

// 主函数：分治法求解最大子数组
Result find_maximum_subarray(int A[], int low, int high) {
    // 基准情况：只有一个元素
    if (high == low) {
        Result result;
        result.sum = A[low];
        result.low = low;
        result.high = high;
        return result;
    } else {
        int mid = (low + high) / 2;

        // 递归求解左半部分
        Result left_result = find_maximum_subarray(A, low, mid);
        // 递归求解右半部分
        Result right_result = find_maximum_subarray(A, mid + 1, high);
        // 求解跨越中点的情况
        Result cross_result = find_max_crossing_subarray(A, low, mid, high);

        // 比较三者，返回最大值
        if (left_result.sum >= right_result.sum && left_result.sum >= cross_result.sum) {
            return left_result;
        } else if (right_result.sum >= left_result.sum && right_result.sum >= cross_result.sum) {
            return right_result;
        } else {
            return cross_result;
        }
    }
}
```

## 4.2 Strassen矩阵乘法

## 4.3 求解递归式

### 4.3.3 主方法 (Master Method)喵～好的我的主人！

（严格按您要求，仅呈现图片内容，并用 `$$` 包裹所有公式）

---

## 主方法 主定理

设 $a \ge 1$ 和 $b > 1$ 为常数，设 $f(n)$ 为一函数，$T(n)$ 是定义在非负整数上的递归：

$$T(n) = aT(n/b) + f(n)$$  
其中 $n/b$ 指 $\lfloor n/b \rfloor$ 或 $\lceil n/b \rceil$。

则 $T(n)$ 可能有如下的渐近界：

1) 若对于某常数 $\varepsilon > 0$，有  
$$f(n) = O\left(n^{\log_b a - \varepsilon}\right)$$  
则  
$$T(n) = \Theta\left(n^{\log_b a}\right)$$

2) 若  
$$f(n) = \Theta\left(n^{\log_b a}\right)$$  
则  
$$T(n) = \Theta\left(n^{\log_b a} \log n\right)$$

3) 若对某常数 $\varepsilon > 0$，有  
$$f(n) = \Omega\left(n^{\log_b a + \varepsilon}\right)$$  
且对常数 $c < 1$ 与所有足够大的 $n$，有  
$$a f(n/b) \le c f(n)$$  
则  
$$T(n) = \Theta(f(n))$$

# 第5章 概率分析和随机算法

