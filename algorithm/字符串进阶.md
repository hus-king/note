# 字符串
## C++ 标准库函数

C++ 标准库操作字符串对象 `std::string`，同时也提供对字符数组的兼容。

参见：`std::basic_string`、`std::basic_string_view`

- **重载了赋值运算符 `+`**：当 `+` 两边是 `string/char/char[]/const char*` 类型时，可以将这两个变量连接，返回连接后的字符串（`string`）。
- **赋值运算符 `=`**：右侧可以是 `const string/string/const char*/char*`。
- **访问运算符 `[cur]`**：返回 `cur` 位置的引用。
- **访问函数 `data()/c_str()`**：返回一个 `const char*` 指针，内容与该 `string` 相同。
- **容量函数 `size()`**：返回字符串字符个数。
- **查找函数 `find(ch, start = 0)`**：查找并返回从 `start` 开始的字符 `ch` 的位置；`rfind(ch)` 从末尾开始，查找并返回第一个找到的字符 `ch` 的位置（皆从 $0$ 开始）（如果查找不到，返回 `-1`）。
- **截取函数 `substr(start, len)`**：可以从字符串的 `start`（从 $0$ 开始）截取一个长度为 `len` 的字符串（缺省 `len` 时代码截取到字符串末尾）。
- **追加函数 `append(s)`**：将 `s` 添加到字符串末尾。
- **追加函数 `append(s, pos, n)`**：将字符串 `s` 中，从 `pos` 开始的 `n` 个字符连接到当前字符串结尾。
- **替换函数 `replace(pos, n, s)`**：删除从 `pos` 开始的 `n` 个字符，然后在 `pos` 处插入串 `s`。
- **删除函数 `erase(pos, n)`**：删除从 `pos` 开始的 `n` 个字符。
- **插入函数 `insert(pos, s)`**：在 `pos` 位置插入字符串 `s`。
- **比较逻辑运算符**：`std::string` 重载了比较逻辑运算符，复杂度是 $\Theta(N)$ 的。

## 字符串匹配

### 暴力做法
简称 BF (Brute Force) 算法。该算法的基本思想是从主串 S 的第一个字符开始和模式串 T 的第一个字符进行比较，若相等，则继续比较二者的后续字符；否则，模式串 T 回退到第一个字符，重新和主串 S 的第二个字符进行比较。如此往复，直到 S 或 T 中所有字符比较完毕。

#### 实现
```cpp
/*
 * s：待匹配的主串
 * t：模式串
 * n：主串的长度
 * m：模式串的长度
 */
std::vector<int> match(char *s, char *t, int n, int m) {
  std::vector<int> ans;
  int i, j;
  for (i = 0; i < n - m + 1; i++) {
    for (j = 0; j < m; j++) {
      if (s[i + j] != t[j]) break;
    }
    if (j == m) ans.push_back(i);
  }
  return ans;
}
```
#### 时间复杂度

设 $ n $ 为主串的长度，$ m $ 为模式串的长度。默认 $ m \ll n $。

BF 算法匹配成功时，在最好情况下，只有一趟匹配成功，此趟比较次数为 $ m $，而其余每趟不成功的匹配都发生在模式串的第一个字符，还需要 $ n - m $ 次比较，总比较次数为 $ n $，故时间复杂度为 $ O(n) $；在最坏情况下，匹配成功的趟数为 $ n - m + 1 $，每趟比较次数为 $ m $，总比较次数为 $ m(n - m + 1) $，故时间复杂度为 $ O(mn) $。

BF 算法匹配失败时，在最好情况下，每趟不成功的匹配都发生在模式串的第一个字符，BF 算法要执行 $ n - m + 1 $ 次比较，时间复杂度为 $ O(n) $；在最坏情况下，每趟不成功的匹配都发生在模式串的最后一个字符，BF 算法要执行 $ m(n - m + 1) $ 次比较，时间复杂度为 $ O(mn) $。

如果模式串有至少两个不同的字符，则 BF 算法的平均时间复杂度为 $ O(n) $。但是在OI题目中，给出的字符串一般都不是纯随机的。

### Hash 的方法

参见：字符串哈希

### KMP算法

参见：前缀函数与KMP算法

## 字符串哈希
